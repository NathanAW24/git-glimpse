Pull Request Number: 3886
Title: chore(test): update testing libraries and refactor
Base Branch: canary
Head Branch: chore/update-testing-libraries
Author: ryo-manba
URL: https://github.com/nextui-org/nextui/pull/3886
State: MERGED
Created At: 2024-10-14T09:58:11Z
Merged At: 2024-10-14T14:13:04Z
Participants: ryo-manba, jrgarciadev

Description:
üìù Description

Updated test-related libraries and refactor code.
Some warnings still appear during test execution, but I plan to address them separately.
Details of the changes are provided in the inline comments.
‚õ≥Ô∏è Current behavior (updates)

üöÄ New behavior

üí£ Is this a breaking change (Yes/No):

No.
üìù Additional Information

Summary by CodeRabbit
Release Notes


New Features

Improved user interaction testing across various components by utilizing the userEvent library for asynchronous event handling.



Bug Fixes

Updated assertion methods in tests to align with Jest's recommended practices for clarity and consistency.



Documentation

Enhanced test suite organization and readability by removing unnecessary act wrappers around user interactions.



Chores

Updated import statements for testing libraries to reflect a more general React testing approach.



These changes improve the overall reliability and maintainability of the application while ensuring a better testing experience.

Commits:
- chore(test): update testing libraries and refactor\n

Labels:


Comments:
- vercel: [vc]: #Lq5aWOha5JxFnO6oRSbJFDn5w9GvrbUGJt/YQI9cdNU=:eyJpc01vbm9yZXBvIjp0cnVlLCJ0eXBlIjoiZ2l0aHViIiwicHJvamVjdHMiOlt7Im5hbWUiOiJuZXh0dWktZG9jcy12MiIsInJvb3REaXJlY3RvcnkiOiJhcHBzL2RvY3MiLCJpbnNwZWN0b3JVcmwiOiJodHRwczovL3ZlcmNlbC5jb20vbmV4dHVpLW9yZy9uZXh0dWktZG9jcy12Mi9GWVhVbXl1aFVqeW9lc2tNMnFhYlZvU002eFFjIiwicHJldmlld1VybCI6Im5leHR1aS1kb2NzLXYyLWdpdC1jaG9yZS11cGRhdGUtdGVzdGluZy1saWJyYXJpZXMtbmV4dHVpLW9yZy52ZXJjZWwuYXBwIiwibmV4dENvbW1pdFN0YXR1cyI6IkRFUExPWUVEIiwibGl2ZUZlZWRiYWNrIjp7InJlc29sdmVkIjowLCJ1bnJlc29sdmVkIjowLCJ0b3RhbCI6MCwibGluayI6Im5leHR1aS1kb2NzLXYyLWdpdC1jaG9yZS11cGRhdGUtdGVzdGluZy1saWJyYXJpZXMtbmV4dHVpLW9yZy52ZXJjZWwuYXBwIn19LHsibmFtZSI6Im5leHR1aS1zdG9yeWJvb2stdjIiLCJyb290RGlyZWN0b3J5IjoicGFja2FnZXMvc3Rvcnlib29rIiwiaW5zcGVjdG9yVXJsIjoiaHR0cHM6Ly92ZXJjZWwuY29tL25leHR1aS1vcmcvbmV4dHVpLXN0b3J5Ym9vay12Mi9EaTJpM2lVNlBUU1o3YVRHUjR4NVBhYWdNWjdIIiwicHJldmlld1VybCI6Im5leHR1aS1zdG9yeWJvb2stdjItZ2l0LWNob3JlLXVwZGF0ZS10ZXN0aW5nLTRhMTcwOS1uZXh0dWktb3JnLnZlcmNlbC5hcHAiLCJuZXh0Q29tbWl0U3RhdHVzIjoiREVQTE9ZRUQiLCJsaXZlRmVlZGJhY2siOnsicmVzb2x2ZWQiOjAsInVucmVzb2x2ZWQiOjAsInRvdGFsIjowLCJsaW5rIjoibmV4dHVpLXN0b3J5Ym9vay12Mi1naXQtY2hvcmUtdXBkYXRlLXRlc3RpbmctNGExNzA5LW5leHR1aS1vcmcudmVyY2VsLmFwcCJ9fV19
**The latest updates on your projects**. Learn more about [Vercel for Git ‚ÜóÔ∏é](https://vercel.link/github-learn-more)

| Name | Status | Preview | Comments | Updated (UTC) |
| :--- | :----- | :------ | :------- | :------ |
| **nextui-docs-v2** | ‚úÖ Ready ([Inspect](https://vercel.com/nextui-org/nextui-docs-v2/FYXUmyuhUjyoeskM2qabVoSM6xQc)) | [Visit Preview](https://vercel.live/open-feedback/nextui-docs-v2-git-chore-update-testing-libraries-nextui-org.vercel.app?via=pr-comment-visit-preview-link&passThrough=1) | üí¨ [**Add feedback**](https://vercel.live/open-feedback/nextui-docs-v2-git-chore-update-testing-libraries-nextui-org.vercel.app?via=pr-comment-feedback-link) | Oct 14, 2024 10:01am |
| **nextui-storybook-v2** | ‚úÖ Ready ([Inspect](https://vercel.com/nextui-org/nextui-storybook-v2/Di2i3iU6PTSZ7aTGR4x5PaagMZ7H)) | [Visit Preview](https://vercel.live/open-feedback/nextui-storybook-v2-git-chore-update-testing-4a1709-nextui-org.vercel.app?via=pr-comment-visit-preview-link&passThrough=1) | üí¨ [**Add feedback**](https://vercel.live/open-feedback/nextui-storybook-v2-git-chore-update-testing-4a1709-nextui-org.vercel.app?via=pr-comment-feedback-link) | Oct 14, 2024 10:01am |


\n- changeset-bot: ###  ‚ö†Ô∏è  No Changeset found

Latest commit: 24f031cadfd3600958b5d1635d56376d4f09bab3

Merging this PR will not cause a version bump for any packages. If these changes should not result in a new version, you're good to go. **If these changes should result in a version bump, you need to add a changeset.**

<details><summary>This PR includes no changesets</summary>

  When changesets are added to this PR, you'll see the packages that this PR includes changesets for and the associated semver types

</details>

[Click here to learn what changesets are, and how to add one](https://github.com/changesets/changesets/blob/main/docs/adding-a-changeset.md).

[Click here if you're a maintainer who wants to add a changeset to this PR](https://github.com/nextui-org/nextui/new/chore/update-testing-libraries?filename=.changeset/early-chicken-pull.md&value=---%0A%22%40nextui-org%2Fdocs%22%3A%20patch%0A%22%40nextui-org%2Faccordion%22%3A%20patch%0A%22%40nextui-org%2Fautocomplete%22%3A%20patch%0A%22%40nextui-org%2Fbutton%22%3A%20patch%0A%22%40nextui-org%2Fcard%22%3A%20patch%0A%22%40nextui-org%2Fcheckbox%22%3A%20patch%0A%22%40nextui-org%2Fchip%22%3A%20patch%0A%22%40nextui-org%2Fdate-input%22%3A%20patch%0A%22%40nextui-org%2Fdate-picker%22%3A%20patch%0A%22%40nextui-org%2Fdropdown%22%3A%20patch%0A%22%40nextui-org%2Flistbox%22%3A%20patch%0A%22%40nextui-org%2Fmenu%22%3A%20patch%0A%22%40nextui-org%2Fmodal%22%3A%20patch%0A%22%40nextui-org%2Fnavbar%22%3A%20patch%0A%22%40nextui-org%2Fpopover%22%3A%20patch%0A%22%40nextui-org%2Fradio%22%3A%20patch%0A%22%40nextui-org%2Fselect%22%3A%20patch%0A%22%40nextui-org%2Fslider%22%3A%20patch%0A%22%40nextui-org%2Fswitch%22%3A%20patch%0A%22%40nextui-org%2Ftable%22%3A%20patch%0A%22%40nextui-org%2Ftabs%22%3A%20patch%0A%22%40nextui-org%2Ftooltip%22%3A%20patch%0A%22%40nextui-org%2Fuse-clipboard%22%3A%20patch%0A%22%40nextui-org%2Fuse-pagination%22%3A%20patch%0A%22%40nextui-org%2Fuse-ref-state%22%3A%20patch%0A---%0A%0Achore(test)%3A%20update%20testing%20libraries%20and%20refactor%0A)

\n- coderabbitai: <!-- This is an auto-generated comment: summarize by coderabbit.ai -->
<!-- walkthrough_start -->

## Walkthrough
This pull request includes various modifications across multiple files, primarily focusing on enhancing the testing approach for components by adopting the `userEvent` library from `@testing-library/user-event`. Key changes involve removing unnecessary `act` wrappers around asynchronous operations, updating import statements, and refining assertions to align with best practices in Jest. Additionally, adjustments to configuration files and dependency versions in `package.json` are made, particularly concerning Testing Library dependencies, while minor JSX structure changes are also noted.

## Changes

| File | Change Summary |
|------|----------------|
| `apps/docs/components/sandpack/entries.ts` | Removed extraneous line break before `</NextUIProvider>` tag. |
| `jest.config.js` | Updated `setupFilesAfterEnv` to remove `extend-expect` from `@testing-library/jest-dom`. |
| `package.json` | Updated `devDependencies`: removed `@testing-library/react-hooks`, `@types/testing-library__jest-dom`; updated versions for several Testing Library packages and `jest`. |
| `packages/components/accordion/__tests__/accordion.test.tsx` | Updated assertion from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)` and removed unnecessary `act` wrappers. |
| `packages/components/autocomplete/__tests__/autocomplete.test.tsx` | Refactored to use `userEvent` for interactions, removed `act` wrappers, and simplified test structure. |
| `packages/components/button/__tests__/button-group.test.tsx` | Updated assertion from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)`. |
| `packages/components/button/__tests__/button.test.tsx` | Removed `act` wrappers, updated interaction to use `await user.click(...)`. |
| `packages/components/card/__tests__/card.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/checkbox/__tests__/checkbox-group.test.tsx` | Updated to use `await user.click(...)`, added `async` to test signatures. |
| `packages/components/checkbox/__tests__/checkbox.test.tsx` | Updated to use `await user.click(...)`, added `async` to test signatures. |
| `packages/components/chip/__tests__/chip.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/date-input/__tests__/date-input.test.tsx` | Removed `act` wrappers from `await user.tab()`. |
| `packages/components/date-input/__tests__/time-input.test.tsx` | Removed `act` wrappers from `user.tab()` calls. |
| `packages/components/date-picker/__tests__/date-picker.test.tsx` | Removed `act` wrappers, updated focus-related event assertions. |
| `packages/components/dropdown/__tests__/dropdown.test.tsx` | Updated to use `await user.click(...)`, modified assertions to `toHaveBeenCalledTimes`. |
| `packages/components/listbox/__tests__/listbox.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/menu/__tests__/menu.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/modal/__tests__/modal.test.tsx` | Removed `act`, updated assertions to `toHaveBeenCalledTimes`. |
| `packages/components/navbar/__tests__/navbar.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/popover/__tests__/popover.test.tsx` | Removed `act`, updated to use `await user.click(...)`. |
| `packages/components/radio/__tests__/radio.test.tsx` | Updated to use `await user.click(...)`, added `async` to test signatures. |
| `packages/components/select/__tests__/select.test.tsx` | Updated to use `await user.click(...)`, removed `act` wrappers, added dynamic placeholder tests. |
| `packages/components/slider/__tests__/slider.test.tsx` | Updated to use `await user.click(...)`, removed `act` wrappers. |
| `packages/components/switch/__tests__/switch.test.tsx` | Updated to use `await user.click(...)`, added variables for better test structure. |
| `packages/components/table/__tests__/table.test.tsx` | Updated to use `await user.click(...)`, added `async` to test signatures. |
| `packages/components/tabs/__tests__/tabs.test.tsx` | Removed `act` wrappers, updated assertions to `toHaveBeenCalledTimes`. |
| `packages/components/tooltip/__tests__/tooltip.test.tsx` | Updated assertion from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)`. |
| `packages/hooks/use-clipboard/__tests__/clipboard.test.tsx` | Changed import from `@testing-library/react-hooks` to `@testing-library/react`. |
| `packages/hooks/use-pagination/__tests__/use-pagination.test.tsx` | Changed import from `@testing-library/react-hooks` to `@testing-library/react`, updated assertion to `toHaveBeenCalledWith`. |
| `packages/hooks/use-ref-state/__tests__/use-ref-state.test.tsx` | Changed import from `@testing-library/react-hooks` to `@testing-library/react`. |
| `plop/hook/__tests__/{{hookName}}.test.tsx.hbs` | Changed import from `@testing-library/react-hooks` to `@testing-library/react`. |
| `scripts/setup-test.ts` | Changed import from `@testing-library/jest-dom/extend-expect` to `@testing-library/jest-dom`. |

## Possibly related PRs
- **#2186**: Enhancements to the `use-autocomplete.ts` file related to autocomplete functionality.
- **#3000**: Addresses pointer events for the clear button in the autocomplete component.
- **#3788**: Ensures the dropdown remains open after clicking the clear button in the autocomplete component.
- **#3774**: Modifications to the input component regarding the clear button's focus behavior when disabled.
- **#3883**: Changes to `ListboxItem` key handling, potentially affecting selection management in dropdowns.

## Suggested reviewers
- wingkwong
- jrgarciadev

<!-- walkthrough_end --><!-- This is an auto-generated comment: raw summary by coderabbit.ai -->

<!--

```
apps/docs/components/sandpack/entries.ts:
## AI-generated summary of changes
The diff presents modifications to the `rootFile` export in the `apps/docs/components/sandpack/entries.ts` file. The primary change involves the removal of an extraneous line break before the closing `</NextUIProvider>` tag. This adjustment simplifies the JSX structure without altering the functional behavior of the component. The rest of the exports, including `getHtmlFile`, `tailwindConfig`, `postcssConfig`, and `stylesConfig`, remain unchanged, indicating no modifications to their logic or structure.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made.

---

jest.config.js:
## AI-generated summary of changes
The configuration file `jest.config.js` has undergone several modifications. The `setupFilesAfterEnv` array has been altered by removing the `extend-expect` part from the `@testing-library/jest-dom` package, changing it from `["@testing-library/jest-dom/extend-expect", "./scripts/setup-test.ts"]` to `["@testing-library/jest-dom", "./scripts/setup-test.ts"]`. This indicates a shift in the setup for the testing environment, potentially simplifying the imports related to the testing library. No other significant changes to the logic or structure of the configuration are present.

## Alterations to the declarations of exported or public entities
- Configuration updated: `setupFilesAfterEnv` in `jest.config.js` modified from `["@testing-library/jest-dom/extend-expect", "./scripts/setup-test.ts"]` to `["@testing-library/jest-dom", "./scripts/setup-test.ts"]`

---

package.json:
## AI-generated summary of changes
The `package.json` file for the `nextui` project has undergone several updates primarily in the `devDependencies` section. Notable changes include the removal of several dependencies related to the Testing Library, specifically:
- `@testing-library/react-hooks` and `@types/testing-library__jest-dom` have been removed.
- The versions of existing Testing Library dependencies have been updated, with `@testing-library/dom`, `@testing-library/jest-dom`, `@testing-library/react`, and `@testing-library/user-event` receiving significant version upgrades.

Additionally, the `jest` and `jest-environment-jsdom` dependencies have also been updated to newer versions. The overall structure of the `package.json` remains intact, with no changes to the scripts or other sections outside of the `devDependencies`.

The `engines` field specifies that the project requires Node version `>=20.x` and pnpm version `>=9.x`, and the `packageManager` field indicates the use of `pnpm@9.6.0`.

## Alterations to the declarations of exported or public entities
- Dependency version updated: `@testing-library/dom` from `^8.1.0` to `^10.4.0`
- Dependency version updated: `@testing-library/jest-dom` from `^5.16.4` to `^6.5.0`
- Dependency version updated: `@testing-library/react` from `^14.0.0` to `^16.0.1`
- Dependency version updated: `@testing-library/user-event` from `^14.4.3` to `^14.5.2`
- Dependency version updated: `@types/jest` from `^28.1.1` to `^29.5.13`
- Dependency version updated: `jest` from `^28.1.1` to `^29.7.0`
- Dependency version updated: `jest-environment-jsdom` from `^28.1.1` to `^28.1.3`

---

packages/components/accordion/__tests__/accordion.test.tsx:
## AI-generated summary of changes
The diff presents modifications to the test suite for the `Accordion` component, primarily focusing on the adjustment of assertions and the removal of unnecessary `act` wrappers around certain asynchronous operations. The changes include:
1. **Assertion Updates**: The assertion for the console error spy has been changed from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)`, enhancing clarity in the test's intent.
2. **Removal of `act` Wrappers**: Several instances of `act(async () => {...})` have been simplified by removing the `act` wrapper around user interactions, such as clicks and keyboard events.
3. **Focus Management**: The focus management logic remains intact, ensuring that the accordion items respond correctly to user interactions without the additional `act` wrappers, which are unnecessary in this context.

Overall, the changes streamline the test code, making it cleaner and more straightforward while maintaining the same testing logic and coverage.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/autocomplete/__tests__/autocomplete.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Autocomplete` component, primarily focusing on the usage of the `userEvent` library from `@testing-library/user-event`. The changes include the import of `UserEvent` and the initialization of a `user` variable in the `beforeEach` hook, which sets up the user event handling for the tests. This refactoring replaces the previous usage of `userEvent.click` with `await user.click`, streamlining the interaction with the component.

Additionally, the tests have been updated to remove the `act` wrapper around `userEvent` calls, as it is no longer necessary with the new setup. This change is reflected in multiple test cases where interactions such as clicking on the autocomplete component, options, and buttons are simplified. The overall structure of the tests remains intact, but the interaction methods are now more concise.

The tests cover various scenarios, including rendering, selection, validation, and interaction with the autocomplete component, ensuring that the component behaves as expected under different conditions. The changes enhance the clarity and maintainability of the test code without altering the underlying functionality of the `Autocomplete` component.

## Alterations to the declarations of exported or public entities
- Import updated: `import userEvent from "@testing-library/user-event";` ‚Üí `import userEvent, {UserEvent} from "@testing-library/user-event";` in `packages/components/autocomplete/__tests__/autocomplete.test.tsx`

---

packages/components/button/__tests__/button-group.test.tsx:
## AI-generated summary of changes
The diff introduces a modification to the test suite for the `ButtonGroup` component in the file `button-group.test.tsx`. The primary change is in the assertion method used to verify the number of times a handler function is called when a button within a disabled `ButtonGroup` is clicked. The line:
```javascript
expect(handler).toBeCalledTimes(0);
```
has been updated to:
```javascript
expect(handler).toHaveBeenCalledTimes(0);
```
This change reflects a shift from one Jest assertion method to another, which may enhance clarity or consistency in the test assertions. No other functional changes or additional tests have been introduced in this diff.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/button/__tests__/button.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Button` component. Notably, it removes the `act` function from the tests, which was previously used to wrap state updates and side effects. Instead, it incorporates the `userEvent` library to handle user interactions more effectively. A `user` variable of type `UserEvent` is declared and initialized in a `beforeEach` block, ensuring that user interactions are set up before each test runs.

The test for triggering the `onPress` function is updated to be asynchronous, reflecting the change in how button clicks are simulated. The button click is now performed using `await user.click(button)` instead of the previous synchronous approach with `act`. This change is mirrored in the test that checks for event handling when the button is disabled, which also transitions to an asynchronous click simulation.

Overall, the modifications enhance the testing approach by leveraging the `userEvent` library for more realistic user interaction simulations, while also ensuring that the tests are structured to handle asynchronous behavior.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/card/__tests__/card.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Card` component located in `packages/components/card/__tests__/card.test.tsx`. Notably, the import statement for `act` from `@testing-library/react-hooks` has been removed and replaced with an import for `userEvent` from `@testing-library/user-event`. 

In the test case "should be clicked when is pressable", the function signature has been updated to be asynchronous (`async () =>`). The previous synchronous click simulation using `act` has been replaced with an asynchronous user event simulation. Specifically, the `button.click()` method call has been removed, and instead, a `user` instance is created using `userEvent.setup()`, followed by an `await user.click(button)` to simulate the click event.

Overall, these changes enhance the interaction testing of the `Card` component by utilizing the `userEvent` library for more realistic user interactions.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/checkbox/__tests__/checkbox-group.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `CheckboxGroup` component. Notably, the import statement for `userEvent` has been updated to include a named import `UserEvent`. A new variable `user` of type `UserEvent` is declared and initialized in a `beforeEach` block, ensuring that `userEvent.setup()` is called before each test, which standardizes user interactions across tests.

The test cases have been updated to utilize the `user` variable for simulating user interactions. Specifically, the `click` method on checkboxes has been changed from a direct DOM manipulation approach using `act` to an asynchronous call using `await user.click(...)`. This change is applied in multiple test cases, including those that check the functionality of changing checkbox values and handling controlled values.

Additionally, the `it` blocks for tests that involve user interactions have been modified to include the `async` keyword, indicating that these tests will handle asynchronous operations. This adjustment ensures that the tests properly await user interactions, which is crucial for accurate simulation of user behavior.

Overall, the changes enhance the structure and reliability of the tests by ensuring that user interactions are handled consistently and asynchronously.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/checkbox/__tests__/checkbox-group.test.tsx`
- Method signature updated: `it("should change value after click", () => {...}` in `packages/components/checkbox/__tests__/checkbox-group.test.tsx` ‚Üí `it("should change value after click", async () => {...}` in `packages/components/checkbox/__tests__/checkbox-group.test.tsx`
- Method signature updated: `it("should work correctly with controlled value", () => {...}` in `packages/components/checkbox/__tests__/checkbox-group.test.tsx` ‚Üí `it("should work correctly with controlled value", async () => {...}` in `packages/components/checkbox/__tests__/checkbox-group.test.tsx`

---

packages/components/checkbox/__tests__/checkbox.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Checkbox` component, primarily enhancing the use of the `userEvent` API from the Testing Library. A new variable `user` of type `UserEvent` is declared and initialized in a `beforeEach` block to streamline user interactions across multiple tests. The tests for clicking the checkbox and handling events when disabled have been updated to use `await user.click(...)` instead of the previous synchronous `act` method, improving the handling of asynchronous interactions.

Additionally, the test descriptions for several tests have been modified to include `async` in their signatures, indicating that they now handle asynchronous operations. The assertions for checking if event handlers were called have been updated from `toBeCalled()` to `toHaveBeenCalled()`, aligning with the recommended Jest matcher syntax. The test for submitting the form has also been adjusted to ensure that the checkbox is clicked asynchronously.

Overall, these changes enhance the clarity and reliability of the tests by ensuring that user interactions are handled correctly in an asynchronous context.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/checkbox/__tests__/checkbox.test.tsx`
- Method signature updated: `it("should change value after click", () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx` ‚Üí `it("should change value after click", async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx`
- Method signature updated: `it("should ignore events when disabled", () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx` ‚Üí `it("should ignore events when disabled", async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx`
- Method signature updated: `it('should work correctly with "onChange" prop', () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx` ‚Üí `it('should work correctly with "onChange" prop', async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx`
- Method signature updated: `it("should work correctly with controlled value", () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx` ‚Üí `it("should work correctly with controlled value", async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx`
- Method signature updated: `it("should submit form when required field is not empty", async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx` ‚Üí `it("should submit form when required field is not empty", async () => {...}` in `packages/components/checkbox/__tests__/checkbox.test.tsx`

---

packages/components/chip/__tests__/chip.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Chip` component in the file `packages/components/chip/__tests__/chip.test.tsx`. Notably, the import statement for `act` from `@testing-library/react-hooks` has been removed and replaced with an import for `userEvent` from `@testing-library/user-event`. 

In the test case "should call onClose when close button is clicked," the function signature has been updated to be asynchronous by adding the `async` keyword. The test now utilizes `userEvent.setup()` to create a user event instance, allowing for the simulation of a click event on the close button. The previous synchronous approach using `act` has been removed, and the click event is awaited, ensuring that the test properly handles the asynchronous nature of user interactions.

Overall, these changes enhance the testing methodology by adopting a more modern approach to user event simulation, aligning with best practices in React testing.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/date-input/__tests__/date-input.test.tsx:
## AI-generated summary of changes
The diff presents modifications to the test suite for the `DateInput` component, primarily focusing on the removal of `act` wrappers around certain asynchronous user interactions. Specifically, the `act` function calls have been eliminated from the `await user.tab()` statements in multiple test cases, including those that check for focus management and event handling. This change simplifies the code by directly using `await user.tab()` without wrapping it in `act`, which is typically used to ensure that all updates related to state and effects are processed before assertions are made. The overall structure and logic of the tests remain intact, with no alterations to the expected outcomes or the functionality being tested.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/date-input/__tests__/time-input.test.tsx:
## AI-generated summary of changes
The diff presents modifications to the test suite for the `TimeInput` component, primarily focusing on the removal of `act` wrappers around `user.tab()` calls in several test cases. This change simplifies the asynchronous handling of user interactions by directly invoking `user.tab()` without wrapping it in `act`, which is typically used to ensure that all updates related to state and effects are processed before assertions are made. The tests affected include those checking focus behavior when tabbing through segments, ensuring that the focus remains on the correct segment and that the appropriate event handlers are called. 

Additionally, the import statement for `act` has been removed, indicating that it is no longer necessary for the tests. The overall structure and assertions of the tests remain unchanged, focusing on the functionality of the `TimeInput` component, including rendering, labeling, event handling, and validation.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/date-picker/__tests__/date-picker.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `DatePicker` component, primarily focusing on the handling of user interactions and event assertions. Key changes include the removal of `act` wrappers around `user.tab()` calls, simplifying the asynchronous handling of focus changes. This adjustment streamlines the focus management during tab navigation, ensuring that the expected elements receive focus without the additional overhead of `act`. 

Additionally, the test cases for event handling have been refined. The assertions for focus-related events (`onBlur`, `onFocus`, and `onFocusChange`) have been updated to reflect the new structure, ensuring that the correct number of calls to these event handlers is verified after user interactions. The tests now directly await user actions without wrapping them in `act`, which may improve readability and maintainability.

The overall structure of the tests remains intact, with a focus on verifying the rendering and functionality of the `DatePicker` component, including its ability to handle various props and user interactions. The changes enhance the clarity of the test cases while maintaining their original intent.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/dropdown/__tests__/dropdown.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Dropdown` component, primarily enhancing the usage of the `userEvent` library for simulating user interactions. The `userEvent` import is updated to include the `UserEvent` type, and a `user` variable is initialized in the `beforeEach` hook to set up the user event handling for each test. This change standardizes the way user interactions are simulated across the tests.

The tests have been updated to replace instances of `await act(async () => { await userEvent.click(...) })` with `await user.click(...)`, simplifying the syntax and improving readability. This change is applied consistently across various tests, including those that check for button clicks, menu interactions, and selection changes.

Assertions have been modified to use `toHaveBeenCalledTimes` instead of `toBeCalledTimes`, aligning with the recommended Jest matchers for clarity. This change is reflected in multiple tests where event handlers are verified for the number of times they have been called.

Additionally, the tests for keyboard interactions have been restructured slightly, maintaining the same functionality but improving the organization of the code. The tests for checking the behavior of the dropdown when items are disabled have also been updated to use the new user event handling approach.

Overall, the changes enhance the clarity and maintainability of the test code while ensuring that the functionality of the `Dropdown` component is thoroughly tested.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/dropdown/__tests__/dropdown.test.tsx`
- Variable initialized: `user = userEvent.setup();` in `packages/components/dropdown/__tests__/dropdown.test.tsx`

---

packages/components/listbox/__tests__/listbox.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Listbox` component. Notably, it adds a `UserEvent` setup in the `beforeEach` block, allowing for more streamlined user interactions in the tests. The import statement for `userEvent` is updated to include `UserEvent`, which is then instantiated in the `beforeEach` method. 

The test cases for single and multiple selections have been modified to replace the usage of `act` with direct calls to `user.click`, simplifying the interaction logic. This change is reflected in the tests for both single and multiple selection modes, where the previous asynchronous `act` wrapper is removed, and the assertions are updated to use `toHaveBeenCalledTimes` instead of `toBeCalledTimes`.

Overall, the changes enhance the clarity and efficiency of the test cases by reducing unnecessary complexity in the user interaction handling.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/listbox/__tests__/listbox.test.tsx`
- Variable initialization added: `user = userEvent.setup();` in `packages/components/listbox/__tests__/listbox.test.tsx`

---

packages/components/menu/__tests__/menu.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Menu` component in `menu.test.tsx`. Notably, it adds a `user` variable of type `UserEvent`, which is initialized in a `beforeEach` block using `userEvent.setup()`. This change standardizes user event handling across tests. 

The test cases have been updated to replace the use of `act` with direct calls to `user.click()`, simplifying the asynchronous interactions with menu items. This adjustment is made in multiple test cases, including those for single and multiple selections, as well as for dispatching action events. The expectation assertions have also been updated to use `toHaveBeenCalledTimes` instead of `toBeCalledTimes`, aligning with the latest Jest matchers.

Overall, the changes enhance the clarity and maintainability of the tests by streamlining user interactions and updating assertion styles.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/menu/__tests__/menu.test.tsx`
- Method signature updated: `await userEvent.click(menuItems[1]);` in `packages/components/menu/__tests__/menu.test.tsx` ‚Üí `await user.click(menuItems[1]);` in `packages/components/menu/__tests__/menu.test.tsx`
- Method signature updated: `await userEvent.click(menuItems[0]);` in `packages/components/menu/__tests__/menu.test.tsx` ‚Üí `await user.click(menuItems[0]);` in `packages/components/menu/__tests__/menu.test.tsx`

---

packages/components/modal/__tests__/modal.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Modal` component. Notably, it removes the import of `act` from `@testing-library/react` and adds an import for `userEvent` from `@testing-library/user-event`. This change indicates a shift in how user interactions are simulated within the tests.

In the first test case, the assertion checking the number of times the console error spy was called has been updated from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)`, reflecting a more precise matcher usage.

The test for firing the `onOpenChange` callback when the close button is clicked has been modified to use `async` and `await` with `userEvent`. The previous synchronous approach using `act` and directly clicking the button has been replaced with an asynchronous user interaction simulation, enhancing the accuracy of the test regarding user events.

Overall, these changes streamline the testing process and improve the handling of user interactions in the test suite.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/components/navbar/__tests__/navbar.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Navbar` component, primarily enhancing the testing methodology by incorporating the `userEvent` library for simulating user interactions. The import statement is updated to include `userEvent` and its type `UserEvent`. A new variable `user` of type `UserEvent` is declared and initialized in a `beforeEach` block, ensuring that user interactions are set up before each test case.

The test cases are updated to replace the previous synchronous click simulation using `act()` with asynchronous calls to `user.click()`, reflecting a more accurate representation of user behavior. This change is applied to multiple test cases, including those that check for error handling after toggle clicks, rendering with menus, and invoking the `onChange` callback when the toggle is clicked. Additionally, the test descriptions are updated to indicate that they are now asynchronous, denoted by the `async` keyword in the function signatures.

Overall, the changes enhance the robustness of the tests by ensuring that user interactions are handled asynchronously, which is more aligned with real-world usage scenarios.

## Alterations to the declarations of exported or public entities
- Import added: `import userEvent, {UserEvent} from "@testing-library/user-event";` in `packages/components/navbar/__tests__/navbar.test.tsx`
- Variable declared: `let user: UserEvent;` in `packages/components/navbar/__tests__/navbar.test.tsx`

---

packages/components/popover/__tests__/popover.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Popover` component, primarily enhancing the usage of the `userEvent` API from the `@testing-library/user-event` package. The import statement for `userEvent` is updated to include a type import for `UserEvent`. A `beforeEach` block is added to initialize the `user` variable with `userEvent.setup()`, allowing for more consistent and asynchronous event handling in the tests.

The test cases have been updated to replace synchronous event simulation using `act` and direct method calls with asynchronous calls to `user.click()`. This change is reflected in multiple test cases, including those that check for popover opening and closing behavior, ensuring that the tests correctly await user interactions. The assertions for the number of times the `spy` function is called have also been updated to use `toHaveBeenCalledTimes` instead of `toBeCalledTimes`.

The test descriptions have been slightly modified to include the `async` keyword where necessary, indicating that the tests involve asynchronous operations. Overall, the changes improve the clarity and reliability of the tests by leveraging the asynchronous capabilities of the `userEvent` API.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/popover/__tests__/popover.test.tsx`
- Variable initialized: `user = userEvent.setup();` in `packages/components/popover/__tests__/popover.test.tsx`

---

packages/components/radio/__tests__/radio.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Radio` component, primarily enhancing the interaction tests with the `userEvent` API from `@testing-library/user-event`. A new variable `user` of type `UserEvent` is declared and initialized in a `beforeEach` block to streamline user interactions across multiple tests. 

The test cases have been updated to use asynchronous interactions with `await user.click(...)` instead of the synchronous `act` method for simulating clicks. This change is applied to multiple tests, including those that check the functionality of changing values upon clicking radio buttons, handling disabled states, and verifying the `onValueChange` prop. 

Additionally, the test descriptions have been updated to reflect the asynchronous nature of the interactions, with the keyword `async` added to the relevant test functions. The assertions have also been modified to use `toHaveBeenCalled()` instead of `toBeCalled()`, aligning with the latest Jest matchers for better readability and consistency.

Overall, the changes enhance the clarity and reliability of the tests by ensuring that user interactions are handled asynchronously, which is more representative of real-world usage.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/radio/__tests__/radio.test.tsx`
- Variable initialized: `user = userEvent.setup();` in `packages/components/radio/__tests__/radio.test.tsx` (within `beforeEach` and `beforeAll` blocks)

---

packages/components/select/__tests__/select.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Select` component, primarily focusing on the usage of the `userEvent` library and the structure of the tests. Key changes include:
1. **Import Adjustments**: The import statement for `userEvent` has been modified to include `UserEvent` from `@testing-library/user-event`, enhancing type safety.
2. **Type Annotations**: The variable `user` is explicitly typed as `UserEvent`, improving clarity and type checking.
3. **Removal of `act` Wrappers**: The use of `act` from React Testing Library has been removed in multiple instances where it was previously wrapping user interactions. This change simplifies the test code by directly calling user interactions without the additional `act` function, which is no longer necessary for these operations.
4. **Assertions Update**: The assertions for checking the number of times `onSelectionChange` is called have been updated from `toBeCalledTimes` to `toHaveBeenCalledTimes`, aligning with the latest Jest matchers.
5. **Dynamic Placeholder Tests**: The tests for dynamic placeholders and rendering values have been streamlined, removing unnecessary `act` wrappers around user interactions.
6. **Form Submission Tests**: The form submission tests have been adjusted to remove `act` wrappers, simplifying the interaction flow while maintaining the same assertions.
7. **Label Placement Tests**: Tests for label placement have been added, ensuring that the label appears correctly based on the `labelPlacement` prop.
8. **React Hook Form Integration**: The integration tests with React Hook Form have been updated to include `aria-label` attributes for better accessibility and clarity in the test setup.

Overall, the changes enhance the readability and maintainability of the test suite while ensuring compliance with updated testing practices.

## Alterations to the declarations of exported or public entities
- Variable type updated: `let user;` in `packages/components/select/__tests__/select.test.tsx` ‚Üí `let user: UserEvent;` in `packages/components/select/__tests__/select.test.tsx`
- Method signature updated: `userEvent` import updated to include `UserEvent` in `packages/components/select/__tests__/select.test.tsx`

---

packages/components/slider/__tests__/slider.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Slider` component in `slider.test.tsx`. Notably, it adds a setup for user events by importing `UserEvent` and initializing it in a `beforeEach` block. This change allows for a more structured approach to handling user interactions in the tests. 

The tests themselves remain largely unchanged in terms of their structure and assertions, but there are key updates in how user interactions are handled. Specifically, instances of `await act(async () => { await userEvent.click(...) })` have been simplified to `await user.click(...)`, streamlining the code and reducing unnecessary complexity in the event handling.

The tests cover various functionalities of the `Slider` component, including rendering, ref forwarding, aria-label support, label handling, min/max value support, disabled state, focus management, controlled values, range values, and the handling of marks. The changes do not alter the core logic of the tests but enhance the clarity and efficiency of user event interactions.

Overall, the modifications focus on improving the test code's readability and maintainability without changing the underlying functionality being tested.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/slider/__tests__/slider.test.tsx`
- Variable initialized: `user = userEvent.setup();` in `packages/components/slider/__tests__/slider.test.tsx`

---

packages/components/switch/__tests__/switch.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Switch` component, primarily enhancing the use of the `userEvent` library for simulating user interactions. Key changes include the addition of a `user` variable initialized in a `beforeEach` block, which sets up the user event handling for all tests. This change allows for the use of `await user.click(...)` instead of the previous synchronous `act(() => { checkbox.click(); })` pattern, improving the handling of asynchronous events.

The test cases have been updated to reflect this new approach, with several tests now marked as `async` to accommodate the asynchronous nature of user interactions. Specifically, tests that check the functionality of the switch, such as checking and unchecking, have been modified to use `await user.click(...)`. This change is consistent across multiple tests, including those that verify behavior when the switch is disabled or read-only, as well as those that handle controlled state.

Additionally, the test descriptions have been updated to include `async` in their signatures where applicable, indicating the asynchronous nature of the operations being tested. The overall structure of the tests remains intact, but the modifications enhance the clarity and correctness of the event simulation.

The changes also include the import of `UserEvent` from the `@testing-library/user-event` package, which is now explicitly typed for better clarity in the code.

Overall, the modifications streamline the testing process by ensuring that user interactions are handled in an asynchronous manner, aligning with best practices for testing React components.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/switch/__tests__/switch.test.tsx`
- Variable added: `let switch1: HTMLInputElement;` in `packages/components/switch/__tests__/switch.test.tsx`
- Variable added: `let switch2: HTMLInputElement;` in `packages/components/switch/__tests__/switch.test.tsx`
- Variable added: `let switch3: HTMLInputElement;` in `packages/components/switch/__tests__/switch.test.tsx`
- Variable added: `let submitButton: HTMLButtonElement;` in `packages/components/switch/__tests__/switch.test.tsx`
- Variable added: `let onSubmit: () => void;` in `packages/components/switch/__tests__/switch.test.tsx`

---

packages/components/table/__tests__/table.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Table` component. Notably, it imports the `UserEvent` type from `@testing-library/user-event` and initializes a `user` variable in the `beforeEach` block to set up user events for testing. This change enhances the handling of user interactions within the tests.

The test cases have been updated to use `await user.click(...)` instead of the previous synchronous `act(() => { ... })` calls for simulating clicks on table rows. This adjustment applies to the tests for both single and multiple selection modes, ensuring that the user interactions are handled asynchronously.

Additionally, the test for setting the `aria-sort` attribute on a column header has been modified to include `async` in its definition, reflecting the asynchronous nature of the user event click simulation. The overall structure of the tests remains intact, but the changes improve the accuracy and reliability of user interaction simulations.

The modifications do not alter the fundamental logic of the tests but enhance their robustness by ensuring that user events are processed correctly in an asynchronous context.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/table/__tests__/table.test.tsx`
- Method signature updated: `it("should work with single selectionMode='single'", () => {...}` in `packages/components/table/__tests__/table.test.tsx` ‚Üí `it("should work with single selectionMode='single'", async () => {...}` in `packages/components/table/__tests__/table.test.tsx`
- Method signature updated: `it("should work with single selectionMode='multiple'", () => {...}` in `packages/components/table/__tests__/table.test.tsx` ‚Üí `it("should work with single selectionMode='multiple'", async () => {...}` in `packages/components/table/__tests__/table.test.tsx`
- Method signature updated: `it("should set the proper aria-sort on an ascending sorted column header", () => {...}` in `packages/components/table/__tests__/table.test.tsx` ‚Üí `it("should set the proper aria-sort on an ascending sorted column header", async () => {...}` in `packages/components/table/__tests__/table.test.tsx`

---

packages/components/tabs/__tests__/tabs.test.tsx:
## AI-generated summary of changes
The diff introduces several modifications to the test suite for the `Tabs` component in `tabs.test.tsx`. Notably, it updates the import statement for `userEvent` to include a named import `UserEvent`, allowing for a more structured setup of user interactions. A new variable `user` of type `UserEvent` is declared and initialized in a `beforeEach` block, ensuring that user interactions are consistently set up before each test.

The tests have been streamlined by removing unnecessary `act` wrappers around `userEvent.keyboard` calls, simplifying the asynchronous keyboard interaction logic. This change enhances readability and reduces the complexity of the test cases. The assertions for checking the number of calls to `console.error` have been updated from `toBeCalledTimes(0)` to `toHaveBeenCalledTimes(0)`, aligning with best practices in Jest assertions.

Overall, the modifications focus on improving the structure and clarity of the test cases while ensuring that the functionality of the `Tabs` component is thoroughly validated.

## Alterations to the declarations of exported or public entities
- Variable added: `let user: UserEvent;` in `packages/components/tabs/__tests__/tabs.test.tsx`
- Variable initialized: `user = userEvent.setup();` in `packages/components/tabs/__tests__/tabs.test.tsx`

---

packages/components/tooltip/__tests__/tooltip.test.tsx:
## AI-generated summary of changes
The diff introduces modifications to the test suite for the `Tooltip` component located in `packages/components/tooltip/__tests__/tooltip.test.tsx`. The changes include an update to the assertion method used to verify the number of times a warning has been logged to the console. Specifically, the line that previously used `toBeCalledTimes(0)` has been changed to `toHaveBeenCalledTimes(0)`, which aligns with the Jest testing framework's recommended syntax for checking the number of calls to a mock function. This change enhances clarity and consistency in the test assertions. 

Additionally, the test suite maintains its structure, with tests verifying the behavior of the `Tooltip` component under various conditions, such as rendering without children, forwarding refs, and handling keyboard events. The overall logic and control flow of the tests remain unchanged, focusing on the expected behavior of the `Tooltip` component.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/hooks/use-clipboard/__tests__/clipboard.test.tsx:
## AI-generated summary of changes
The diff reflects a modification in the import statement for the testing library used in the `clipboard.test.tsx` file. The import of `renderHook` and `act` has been changed from `@testing-library/react-hooks` to `@testing-library/react`. This change may affect how hooks are rendered and tested, as the new import suggests a shift to a more general React testing approach rather than a hooks-specific one. The rest of the test suite remains unchanged, including the setup for mocking the clipboard API and the test case that verifies the functionality of the `useClipboard` hook.

## Alterations to the declarations of exported or public entities
- Import modified: `import {renderHook, act} from "@testing-library/react-hooks";` in `packages/hooks/use-clipboard/__tests__/clipboard.test.tsx` ‚Üí `import {renderHook, act} from "@testing-library/react";` in `packages/hooks/use-clipboard/__tests__/clipboard.test.tsx`

---

packages/hooks/use-pagination/__tests__/use-pagination.test.tsx:
## AI-generated summary of changes
The diff reflects modifications to the test file for the `usePagination` hook, specifically changing the import statement and updating an assertion method. The import statement for `renderHook` and `act` has been altered from `@testing-library/react-hooks` to `@testing-library/react`, indicating a shift in the testing library's usage. Additionally, in the last test case, the assertion method for verifying the call of the `onChange` function has been updated from `toBeCalledWith` to `toHaveBeenCalledWith`, which is a more current and preferred matcher in Jest for checking function calls. No other changes to the logic or structure of the tests are present.

## Alterations to the declarations of exported or public entities
- No alterations to the declarations of exported or public entities were made in this diff.

---

packages/hooks/use-ref-state/__tests__/use-ref-state.test.tsx:
## AI-generated summary of changes
The diff modifies the import statement for the testing library in the `use-ref-state.test.tsx` file. The `renderHook` and `act` functions are now imported from `@testing-library/react` instead of `@testing-library/react-hooks`. This change affects how hooks are tested within the file. The test cases for the `useRefState` hook remain unchanged in terms of their logic and assertions, focusing on verifying the correct behavior of the hook in various scenarios, including initial state, functional updates, and reference tracking.

## Alterations to the declarations of exported or public entities
- Import modified: `import {renderHook, act} from "@testing-library/react-hooks";` ‚Üí `import {renderHook, act} from "@testing-library/react";` in `packages/hooks/use-ref-state/__tests__/use-ref-state.test.tsx`

---

plop/hook/__tests__/{{hookName}}.test.tsx.hbs:
## AI-generated summary of changes
The diff shows a modification in the import statement for the `renderHook` function. The import has been changed from `@testing-library/react-hooks` to `@testing-library/react`. This change affects how the hook is rendered in the test suite for the `{{camelCase hookName}}` function. The overall structure of the test remains the same, with the `describe` and `it` blocks unchanged, indicating that the functionality of the test itself is preserved while the method of rendering the hook has been updated.

## Alterations to the declarations of exported or public entities
- Import statement modified: `import {renderHook} from "@testing-library/react-hooks";` in `plop/hook/__tests__/{{hookName}}.test.tsx.hbs` ‚Üí `import {renderHook} from "@testing-library/react";` in `plop/hook/__tests__/{{hookName}}.test.tsx.hbs`

---

scripts/setup-test.ts:
## AI-generated summary of changes
The diff modifies the import statement for the `@testing-library/jest-dom` package by removing the specific import of `extend-expect`, now importing the entire package instead. This change may affect how matchers are extended in the testing environment. The setup for `window.getComputedStyle` remains unchanged, ensuring that the computed styles can still be accessed as before. 

Additionally, the implementation of `window.matchMedia` is defined if it is not already a function, providing a mock implementation that includes methods for event handling, which are marked as deprecated. This mock allows for testing media queries without relying on the actual browser implementation.

A workaround for a known issue with `jsdom` is included, assigning `global.TextEncoder` to the `TextEncoder` from the `util` module. This ensures that the `TextEncoder` is available in the global scope for tests.

Finally, a mock implementation of `global.ResizeObserver` is provided, allowing for the observation of resize events in tests. The configuration for `@testing-library/react` is set to enable React's strict mode based on an environment variable.

## Alterations to the declarations of exported or public entities
- Import modified: `import "@testing-library/jest-dom/extend-expect";` in `scripts/setup-test.ts` ‚Üí `import "@testing-library/jest-dom";` in `scripts/setup-test.ts`
```

-->

<!-- end of auto-generated comment: raw summary by coderabbit.ai --><!-- This is an auto-generated comment: pr objectives by coderabbit.ai -->

<!--

## PR Summary

The pull request titled "chore(test): update testing libraries and refactor" was created by the user ryo-manba and is identified by the number 3886. It can be accessed at the following URL: [https://github.com/nextui-org/nextui/pull/3886](https://github.com/nextui-org/nextui/pull/3886).

The primary focus of this PR is to update test-related libraries and refactor the existing code. The description indicates that the changes aim to enhance the testing framework used within the project. The author has not specified any current behavior that is being modified, nor have they detailed the new behavior introduced by this update.

Additionally, the PR does not introduce any breaking changes, as confirmed by the author. There is no impact or migration path required for existing NextUI users as a result of this update.

Overall, this pull request is a maintenance effort aimed at improving the testing infrastructure without affecting the existing functionality of the project.

-->

<!-- end of auto-generated comment: pr objectives by coderabbit.ai --><!-- commit_ids_reviewed_start -->

<!-- 24f031cadfd3600958b5d1635d56376d4f09bab3 -->

<!-- commit_ids_reviewed_end --><!-- tips_start -->

---

Thank you for using CodeRabbit. We offer it for free to the OSS community and would appreciate your support in helping us grow. If you find it useful, would you consider giving us a shout-out on your favorite social media?

<details>
<summary>‚ù§Ô∏è Share</summary>

- [X](https://twitter.com/intent/tweet?text=I%20just%20used%20%40coderabbitai%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20the%20proprietary%20code.%20Check%20it%20out%3A&url=https%3A//coderabbit.ai)
- [Mastodon](https://mastodon.social/share?text=I%20just%20used%20%40coderabbitai%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20the%20proprietary%20code.%20Check%20it%20out%3A%20https%3A%2F%2Fcoderabbit.ai)
- [Reddit](https://www.reddit.com/submit?title=Great%20tool%20for%20code%20review%20-%20CodeRabbit&text=I%20just%20used%20CodeRabbit%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20proprietary%20code.%20Check%20it%20out%3A%20https%3A//coderabbit.ai)
- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcoderabbit.ai&mini=true&title=Great%20tool%20for%20code%20review%20-%20CodeRabbit&summary=I%20just%20used%20CodeRabbit%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20proprietary%20code)

</details>

<details>
<summary>ü™ß Tips</summary>

### Chat

There are 3 ways to chat with [CodeRabbit](https://coderabbit.ai):

- Review comments: Directly reply to a review comment made by CodeRabbit. Example:
  - `I pushed a fix in commit <commit_id>, please review it.`
  - `Generate unit testing code for this file.`
  - `Open a follow-up GitHub issue for this discussion.`
- Files and specific lines of code (under the "Files changed" tab): Tag `@coderabbitai` in a new review comment at the desired location with your query. Examples:
  - `@coderabbitai generate unit testing code for this file.`
  -	`@coderabbitai modularize this function.`
- PR comments: Tag `@coderabbitai` in a new PR comment to ask questions about the PR branch. For the best results, please provide a very specific query, as very limited context is provided in this mode. Examples:
  - `@coderabbitai gather interesting stats about this repository and render them as a table. Additionally, render a pie chart showing the language distribution in the codebase.`
  - `@coderabbitai read src/utils.ts and generate unit testing code.`
  - `@coderabbitai read the files in the src/scheduler package and generate a class diagram using mermaid and a README in the markdown format.`
  - `@coderabbitai help me debug CodeRabbit configuration file.`

Note: Be mindful of the bot's finite context window. It's strongly recommended to break down tasks such as reading entire modules into smaller chunks. For a focused discussion, use review comments to chat about specific files and their changes, instead of using the PR comments.

### CodeRabbit Commands (Invoked using PR comments)

- `@coderabbitai pause` to pause the reviews on a PR.
- `@coderabbitai resume` to resume the paused reviews.
- `@coderabbitai review` to trigger an incremental review. This is useful when automatic reviews are disabled for the repository.
- `@coderabbitai full review` to do a full review from scratch and review all the files again.
- `@coderabbitai summary` to regenerate the summary of the PR.
- `@coderabbitai resolve` resolve all the CodeRabbit review comments.
- `@coderabbitai configuration` to show the current CodeRabbit configuration for the repository.
- `@coderabbitai help` to get help.

### Other keywords and placeholders

- Add `@coderabbitai ignore` anywhere in the PR description to prevent this PR from being reviewed.
- Add `@coderabbitai summary` to generate the high-level summary at a specific location in the PR description.
- Add `@coderabbitai` anywhere in the PR title to generate the title automatically.

### Documentation and Community

- Visit our [Documentation](https://coderabbit.ai/docs) for detailed information on how to use CodeRabbit.
- Join our [Discord Community](http://discord.gg/coderabbit) to get help, request features, and share feedback.
- Follow us on [X/Twitter](https://twitter.com/coderabbitai) for updates and announcements.

</details>

<!-- tips_end -->\n

Files Changed:
- apps/docs/components/sandpack/entries.ts (modified, 2 changes)\n  Patch: @@ -10,7 +10,7 @@ ReactDOM.createRoot(document.getElementById("root")).render(
     <NextUIProvider>
       <div className="w-screen h-screen p-8 flex items-start justify-center">
         <App />
-      </div>  
+      </div>
     </NextUIProvider>
   </React.StrictMode>
 );`;\n- jest.config.js (modified, 2 changes)\n  Patch: @@ -18,7 +18,7 @@ module.exports = {
     ],
   },
   transformIgnorePatterns: ["[/\\\\]node_modules[/\\\\].+\\.(js|jsx)$"],
-  setupFilesAfterEnv: ["@testing-library/jest-dom/extend-expect", "./scripts/setup-test.ts"],
+  setupFilesAfterEnv: ["@testing-library/jest-dom", "./scripts/setup-test.ts"],
   globals: {
     "ts-jest": {
       tsconfig: "tsconfig.json",\n- package.json (modified, 16 changes)\n  Patch: @@ -73,17 +73,15 @@
     "@swc-node/jest": "^1.5.2",
     "@swc/core": "^1.3.35",
     "@swc/jest": "^0.2.24",
-    "@testing-library/dom": "^8.1.0",
-    "@testing-library/jest-dom": "^5.16.4",
-    "@testing-library/react": "^14.0.0",
-    "@testing-library/react-hooks": "^8.0.1",
-    "@testing-library/user-event": "^14.4.3",
-    "@types/jest": "^28.1.1",
+    "@testing-library/dom": "^10.4.0",
+    "@testing-library/jest-dom": "^6.5.0",
+    "@testing-library/react": "^16.0.1",
+    "@testing-library/user-event": "^14.5.2",
+    "@types/jest": "^29.5.13",
     "@types/node": "^15.12.4",
     "@types/react": "^18.0.1",
     "@types/react-dom": "^18.0.0",
     "@types/shelljs": "^0.8.9",
-    "@types/testing-library__jest-dom": "5.14.5",
     "@typescript-eslint/eslint-plugin": "^5.42.0",
     "@typescript-eslint/parser": "^5.42.0",
     "chalk": "^4.1.2",
@@ -115,8 +113,8 @@
     "gray-matter": "^4.0.3",
     "husky": "^8.0.1",
     "intl-messageformat": "^10.1.0",
-    "jest": "^28.1.1",
-    "jest-environment-jsdom": "^28.1.1",
+    "jest": "^29.7.0",
+    "jest-environment-jsdom": "^28.1.3",
     "jest-watch-typeahead": "1.1.0",
     "lint-staged": "^13.0.3",
     "npm-check-updates": "^16.10.18",\n- packages/components/accordion/__tests__/accordion.test.tsx (modified, 70 changes)\n  Patch: @@ -30,7 +30,7 @@ describe("Accordion", () => {
 
     expect(() => wrapper.unmount()).not.toThrow();
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
   it("ref should be forwarded", () => {
@@ -121,9 +121,7 @@ describe("Accordion", () => {
 
     expect(button).toHaveAttribute("aria-expanded", "false");
 
-    await act(async () => {
-      await user.click(button);
-    });
+    await user.click(button);
 
     expect(button).toHaveAttribute("aria-expanded", "true");
   });
@@ -163,18 +161,12 @@ describe("Accordion", () => {
     const second = wrapper.getByTestId("item-2");
     const secondButton = second.querySelector("button") as HTMLElement;
 
-    act(() => {
-      focus(firstButton);
-    });
-
-    await act(async () => {
-      await user.keyboard("[ArrowDown]");
-    });
+    await focus(firstButton);
+    await user.keyboard("[ArrowDown]");
     expect(secondButton).toHaveFocus();
 
-    await act(async () => {
-      await user.keyboard("[ArrowUp]");
-    });
+    await user.keyboard("[ArrowUp]");
+
     expect(firstButton).toHaveFocus();
   });
 
@@ -200,14 +192,10 @@ describe("Accordion", () => {
       focus(secondButton);
     });
 
-    await act(async () => {
-      await user.keyboard("[Home]");
-    });
+    await user.keyboard("[Home]");
     expect(firstButton).toHaveFocus();
 
-    await act(async () => {
-      await user.keyboard("[End]");
-    });
+    await user.keyboard("[End]");
     expect(secondButton).toHaveFocus();
   });
 
@@ -233,9 +221,7 @@ describe("Accordion", () => {
       focus(firstButton);
     });
 
-    await act(async () => {
-      await user.keyboard("[Tab]");
-    });
+    await user.keyboard("[Tab]");
     expect(secondButton).toHaveFocus();
   });
 
@@ -276,10 +262,7 @@ describe("Accordion", () => {
 
     expect(button).toHaveAttribute("aria-expanded", "false");
 
-    await act(async () => {
-      await user.click(button);
-    });
-
+    await user.click(button);
     expect(button).toHaveAttribute("aria-expanded", "true");
   });
 
@@ -300,17 +283,11 @@ describe("Accordion", () => {
 
     expect(item1.querySelector("[role='region']")).toBeInTheDocument();
 
-    await act(async () => {
-      await user.click(button);
-    });
-
+    await user.click(button);
     const item2 = wrapper.getByTestId("item-2");
     const button2 = item2.querySelector("button") as HTMLElement;
 
-    await act(async () => {
-      await user.click(button2);
-    });
-
+    await user.click(button2);
     expect(item1.querySelector("[role='region']")).toBeInTheDocument();
     expect(item2.querySelector("[role='region']")).toBeInTheDocument();
   });
@@ -331,29 +308,22 @@ describe("Accordion", () => {
 
     const firstButton = await wrapper.getByRole("button", {name: "Accordion Item 1"});
 
-    await act(() => {
+    act(() => {
       focus(firstButton);
     });
-    await act(async () => {
-      await user.keyboard("[Tab]");
-    });
+
+    await user.keyboard("[Tab]");
     expect(input).toHaveFocus();
 
-    await act(async () => {
-      await user.keyboard("aaa");
-    });
+    await user.keyboard("aaa");
     expect(input).toHaveValue("aaa");
 
-    await act(async () => {
-      await user.keyboard("[ArrowLeft]");
-      await user.keyboard("b");
-    });
+    await user.keyboard("[ArrowLeft]");
+    await user.keyboard("b");
     expect(input).toHaveValue("aaba");
 
-    await act(async () => {
-      await user.keyboard("[ArrowRight]");
-      await user.keyboard("c");
-    });
+    await user.keyboard("[ArrowRight]");
+    await user.keyboard("c");
     expect(input).toHaveValue("aabac");
   });
 \n- packages/components/autocomplete/__tests__/autocomplete.test.tsx (modified, 101 changes)\n  Patch: @@ -1,6 +1,6 @@
 import * as React from "react";
 import {within, render, renderHook, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {useForm} from "react-hook-form";
 
 import {Autocomplete, AutocompleteItem, AutocompleteProps, AutocompleteSection} from "../src";
@@ -77,6 +77,12 @@ const AutocompleteExample = (props: Partial<AutocompleteProps> = {}) => (
 );
 
 describe("Autocomplete", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(<AutocompleteExample />);
 
@@ -172,9 +178,7 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -201,19 +205,15 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     let options = wrapper.getAllByRole("option");
 
     // select the target item
-    await act(async () => {
-      await userEvent.click(options[0]);
-    });
+    await user.click(options[0]);
 
     const {container} = wrapper;
 
@@ -224,9 +224,7 @@ describe("Autocomplete", () => {
     expect(clearButton).not.toBeNull();
 
     // click the clear button
-    await act(async () => {
-      await userEvent.click(clearButton);
-    });
+    await user.click(clearButton);
 
     // assert that the input has empty value
     expect(autocomplete).toHaveValue("");
@@ -253,19 +251,15 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     let options = wrapper.getAllByRole("option");
 
     // select the target item
-    await act(async () => {
-      await userEvent.click(options[0]);
-    });
+    await user.click(options[0]);
 
     const {container} = wrapper;
 
@@ -276,9 +270,7 @@ describe("Autocomplete", () => {
     expect(clearButton).not.toBeNull();
 
     // click the clear button
-    await act(async () => {
-      await userEvent.click(clearButton);
-    });
+    await user.click(clearButton);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -294,19 +286,15 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     let options = wrapper.getAllByRole("option");
 
     // select the target item
-    await act(async () => {
-      await userEvent.click(options[0]);
-    });
+    await user.click(options[0]);
 
     const {container} = wrapper;
 
@@ -317,9 +305,7 @@ describe("Autocomplete", () => {
     expect(clearButton).not.toBeNull();
 
     /// click the clear button
-    await act(async () => {
-      await userEvent.click(clearButton);
-    });
+    await user.click(clearButton);
 
     // assert that the input has empty value
     expect(autocomplete).toHaveValue("");
@@ -338,19 +324,15 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     let options = wrapper.getAllByRole("option");
 
     // select the target item
-    await act(async () => {
-      await userEvent.click(options[0]);
-    });
+    await user.click(options[0]);
 
     const {container} = wrapper;
 
@@ -361,9 +343,7 @@ describe("Autocomplete", () => {
     expect(clearButton).not.toBeNull();
 
     // click the clear button
-    await act(async () => {
-      await userEvent.click(clearButton);
-    });
+    await user.click(clearButton);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -395,9 +375,7 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the select listbox by clicking selector button
-    await act(async () => {
-      await userEvent.click(selectorButton);
-    });
+    await user.click(selectorButton);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -406,9 +384,7 @@ describe("Autocomplete", () => {
     expect(autocomplete).toHaveFocus();
 
     // close the select listbox by clicking selector button again
-    await act(async () => {
-      await userEvent.click(selectorButton);
-    });
+    await user.click(selectorButton);
 
     // assert that the autocomplete listbox is closed
     expect(autocomplete).toHaveAttribute("aria-expanded", "false");
@@ -439,17 +415,13 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("close-when-clicking-outside-test");
 
     // open the select listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     // click outside the autocomplete component
-    await act(async () => {
-      await userEvent.click(document.body);
-    });
+    await user.click(document.body);
 
     // assert that the autocomplete is closed
     expect(autocomplete).toHaveAttribute("aria-expanded", "false");
@@ -488,17 +460,14 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("close-when-clicking-outside-test");
 
     // open the autocomplete listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
 
     // click outside the autocomplete component
-    await act(async () => {
-      await userEvent.click(document.body);
-    });
+    await user.click(document.body);
 
     // assert that the autocomplete listbox is closed
     expect(autocomplete).toHaveAttribute("aria-expanded", "false");
@@ -522,9 +491,7 @@ describe("Autocomplete", () => {
     const autocomplete = wrapper.getByTestId("autocomplete");
 
     // open the listbox
-    await act(async () => {
-      await userEvent.click(autocomplete);
-    });
+    await user.click(autocomplete);
 
     // assert that the autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -537,9 +504,7 @@ describe("Autocomplete", () => {
     expect(options.length).toBe(3);
 
     // select the target item
-    await act(async () => {
-      await userEvent.click(options[0]);
-    });
+    await user.click(options[0]);
 
     // assert that the input has target selection
     expect(autocomplete).toHaveValue("Penguin");
@@ -598,9 +563,7 @@ describe("Autocomplete", () => {
     expect(selectorButton2).not.toBeNull();
 
     // open the select listbox by clicking selector button in the first autocomplete
-    await act(async () => {
-      await userEvent.click(selectorButton);
-    });
+    await user.click(selectorButton);
 
     // assert that the first autocomplete listbox is open
     expect(autocomplete).toHaveAttribute("aria-expanded", "true");
@@ -609,9 +572,7 @@ describe("Autocomplete", () => {
     expect(autocomplete).toHaveFocus();
 
     // close the select listbox by clicking the second autocomplete
-    await act(async () => {
-      await userEvent.click(selectorButton2);
-    });
+    await user.click(selectorButton2);
 
     // assert that the first autocomplete listbox is closed
     expect(autocomplete).toHaveAttribute("aria-expanded", "false");\n- packages/components/button/__tests__/button-group.test.tsx (modified, 2 changes)\n  Patch: @@ -35,7 +35,7 @@ describe("ButtonGroup", () => {
     let button = wrapper.getByTestId("button-test");
 
     userEvent.click(button);
-    expect(handler).toBeCalledTimes(0);
+    expect(handler).toHaveBeenCalledTimes(0);
   });
 
   it("should render different variants", () => {\n- packages/components/button/__tests__/button.test.tsx (modified, 25 changes)\n  Patch: @@ -1,9 +1,16 @@
 import * as React from "react";
-import {act, render} from "@testing-library/react";
+import {render} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {Button} from "../src";
 
 describe("Button", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(<Button disableRipple />);
 
@@ -17,24 +24,24 @@ describe("Button", () => {
     expect(ref.current).not.toBeNull();
   });
 
-  it("should trigger onPress function", () => {
+  it("should trigger onPress function", async () => {
     const onPress = jest.fn();
     const {getByRole} = render(<Button disableRipple onPress={onPress} />);
 
-    act(() => {
-      getByRole("button").click();
-    });
+    const button = getByRole("button");
+
+    await user.click(button);
 
     expect(onPress).toHaveBeenCalled();
   });
 
-  it("should ignore events when disabled", () => {
+  it("should ignore events when disabled", async () => {
     const onPress = jest.fn();
     const {getByRole} = render(<Button disableRipple isDisabled onPress={onPress} />);
 
-    act(() => {
-      getByRole("button").click();
-    });
+    const button = getByRole("button");
+
+    await user.click(button);
 
     expect(onPress).not.toHaveBeenCalled();
   });\n- packages/components/card/__tests__/card.test.tsx (modified, 10 changes)\n  Patch: @@ -1,6 +1,6 @@
 import * as React from "react";
 import {render} from "@testing-library/react";
-import {act} from "@testing-library/react-hooks";
+import userEvent from "@testing-library/user-event";
 
 import {Card} from "../src";
 
@@ -24,15 +24,15 @@ describe("Card", () => {
     expect(() => wrapper.unmount()).not.toThrow();
   });
 
-  it("should be clicked when is pressable", () => {
+  it("should be clicked when is pressable", async () => {
     const onPress = jest.fn();
     const {getByRole} = render(<Card disableRipple isPressable onPress={onPress} />);
 
     const button = getByRole("button");
 
-    act(() => {
-      button.click();
-    });
+    const user = userEvent.setup();
+
+    await user.click(button);
 
     expect(onPress).toHaveBeenCalled();
   });\n- packages/components/checkbox/__tests__/checkbox-group.test.tsx (modified, 25 changes)\n  Patch: @@ -1,10 +1,16 @@
 import * as React from "react";
 import {act, render} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {CheckboxGroup, Checkbox} from "../src";
 
 describe("Checkbox.Group", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(
       <CheckboxGroup defaultValue={[]} label="Select cities">
@@ -48,7 +54,7 @@ describe("Checkbox.Group", () => {
     expect(container.querySelector("[data-testid=second-checkbox] input")).not.toBeChecked();
   });
 
-  it("should change value after click", () => {
+  it("should change value after click", async () => {
     let value = ["sydney"];
     const wrapper = render(
       <CheckboxGroup
@@ -67,9 +73,7 @@ describe("Checkbox.Group", () => {
 
     const secondCheckbox = wrapper.getByTestId("second-checkbox");
 
-    act(() => {
-      secondCheckbox.click();
-    });
+    await user.click(secondCheckbox);
 
     expect(value).toEqual(["sydney", "buenos-aires"]);
   });
@@ -98,7 +102,7 @@ describe("Checkbox.Group", () => {
     expect(secondCheckbox).not.toBeChecked();
   });
 
-  it("should work correctly with controlled value", () => {
+  it("should work correctly with controlled value", async () => {
     let checked = ["sydney"];
     const onChange = jest.fn((value) => {
       checked = value;
@@ -125,20 +129,13 @@ describe("Checkbox.Group", () => {
 
     const secondCheckbox = wrapper.getByTestId("second-checkbox");
 
-    act(() => {
-      secondCheckbox.click();
-    });
+    await user.click(secondCheckbox);
 
     expect(onChange).toHaveBeenCalledTimes(1);
     expect(checked).toEqual(["sydney", "buenos-aires"]);
   });
 
   describe("validation", () => {
-    let user = userEvent.setup();
-
-    beforeAll(() => {
-      user = userEvent.setup();
-    });
     describe("validationBehavior=native", () => {
       it("supports group level isRequired", async () => {
         let {getAllByRole, getByRole, getByTestId} = render(\n- packages/components/checkbox/__tests__/checkbox.test.tsx (modified, 52 changes)\n  Patch: @@ -1,11 +1,17 @@
 import * as React from "react";
 import {render, renderHook, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {useForm} from "react-hook-form";
 
 import {Checkbox, CheckboxProps} from "../src";
 
 describe("Checkbox", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(<Checkbox>Label</Checkbox>);
 
@@ -29,25 +35,21 @@ describe("Checkbox", () => {
     expect(container.querySelector("input")?.checked).toBe(false);
   });
 
-  it("should change value after click", () => {
+  it("should change value after click", async () => {
     const wrapper = render(<Checkbox data-testid="checkbox-test">Option</Checkbox>);
     const checkbox = wrapper.container.querySelector("input")!;
 
     expect(checkbox.checked).toBe(false);
 
-    act(() => {
-      wrapper.getByTestId("checkbox-test").click();
-    });
+    await user.click(wrapper.getByTestId("checkbox-test"));
 
     expect(checkbox.checked).toBe(true);
   });
 
-  it("should ignore events when disabled", () => {
+  it("should ignore events when disabled", async () => {
     const {container} = render(<Checkbox isDisabled>Option</Checkbox>);
 
-    act(() => {
-      userEvent.click(container.querySelector("label")!);
-    });
+    await user.click(container.querySelector("label")!);
 
     expect(container.querySelector("input")?.checked).toBe(false);
   });
@@ -58,19 +60,17 @@ describe("Checkbox", () => {
     expect(container.querySelector("input")?.indeterminate).toBe(true);
   });
 
-  it('should work correctly with "onChange" prop', () => {
+  it('should work correctly with "onChange" prop', async () => {
     const onChange = jest.fn();
     const wrapper = render(
       <Checkbox data-testid="checkbox-test" onChange={onChange}>
         Option
       </Checkbox>,
     );
 
-    act(() => {
-      wrapper.getByTestId("checkbox-test").click();
-    });
+    await user.click(wrapper.getByTestId("checkbox-test"));
 
-    expect(onChange).toBeCalled();
+    expect(onChange).toHaveBeenCalled();
   });
 
   it('should work correctly with "onFocus" prop', () => {
@@ -87,7 +87,7 @@ describe("Checkbox", () => {
       input.focus();
     });
 
-    expect(onFocus).toBeCalled();
+    expect(onFocus).toHaveBeenCalled();
   });
 
   it("should have required attribute when isRequired with native validationBehavior", () => {
@@ -112,7 +112,7 @@ describe("Checkbox", () => {
     expect(container.querySelector("input")).toHaveAttribute("aria-required", "true");
   });
 
-  it("should work correctly with controlled value", () => {
+  it("should work correctly with controlled value", async () => {
     const onChange = jest.fn();
 
     const Component = (props: CheckboxProps) => {
@@ -138,20 +138,12 @@ describe("Checkbox", () => {
       </Component>,
     );
 
-    act(() => {
-      wrapper.getByTestId("checkbox-test").click();
-    });
+    await user.click(wrapper.getByTestId("checkbox-test"));
 
-    expect(onChange).toBeCalled();
+    expect(onChange).toHaveBeenCalled();
   });
 
   describe("validation", () => {
-    let user;
-
-    beforeEach(() => {
-      user = userEvent.setup();
-    });
-
     describe("validationBehavior=native", () => {
       it("supports isRequired", async () => {
         const {getByRole, getByTestId} = render(
@@ -257,13 +249,11 @@ describe("Checkbox with React Hook Form", () => {
   });
 
   it("should submit form when required field is not empty", async () => {
-    act(() => {
-      checkbox3.click();
-    });
+    const user = userEvent.setup();
 
-    expect(checkbox3.checked).toBe(true);
+    await user.click(checkbox3);
 
-    const user = userEvent.setup();
+    expect(checkbox3.checked).toBe(true);
 
     await user.click(submitButton);
 \n- packages/components/chip/__tests__/chip.test.tsx (modified, 10 changes)\n  Patch: @@ -1,7 +1,7 @@
 import * as React from "react";
 import {render} from "@testing-library/react";
 import {Avatar} from "@nextui-org/avatar";
-import {act} from "@testing-library/react-hooks";
+import userEvent from "@testing-library/user-event";
 
 import {Chip} from "../src";
 
@@ -49,13 +49,13 @@ describe("Chip", () => {
     expect(wrapper.getByRole("button")).not.toBeNull();
   });
 
-  it("should call onClose when close button is clicked", () => {
+  it("should call onClose when close button is clicked", async () => {
     const onClose = jest.fn();
     const {getByRole} = render(<Chip onClose={onClose} />);
 
-    act(() => {
-      getByRole("button").click();
-    });
+    const user = userEvent.setup();
+
+    await user.click(getByRole("button"));
 
     expect(onClose).toHaveBeenCalled();
   });\n- packages/components/date-input/__tests__/date-input.test.tsx (modified, 35 changes)\n  Patch: @@ -1,6 +1,6 @@
 /* eslint-disable jsx-a11y/no-autofocus */
 import * as React from "react";
-import {act, fireEvent, render} from "@testing-library/react";
+import {fireEvent, render} from "@testing-library/react";
 import {CalendarDate, CalendarDateTime, DateValue, ZonedDateTime} from "@internationalized/date";
 import {pointerMap, triggerPress} from "@nextui-org/test-utils";
 import userEvent from "@testing-library/user-event";
@@ -67,10 +67,7 @@ describe("DateInput", () => {
         />,
       );
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       await user.keyboard("01011980");
 
       expect(tree.getByText("Date unavailable.")).toBeInTheDocument();
@@ -205,17 +202,13 @@ describe("DateInput", () => {
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[0]).toHaveFocus();
 
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[1]).toHaveFocus();
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
@@ -236,22 +229,14 @@ describe("DateInput", () => {
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[0]).toHaveFocus();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[1]).toHaveFocus();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[2]).toHaveFocus();
       expect(onBlurSpy).toHaveBeenCalledTimes(0);
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(onBlurSpy).toHaveBeenCalledTimes(1);
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(2);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
@@ -266,9 +251,7 @@ describe("DateInput", () => {
       expect(onKeyDownSpy).not.toHaveBeenCalled();
       expect(onKeyUpSpy).not.toHaveBeenCalled();
 
-      await act(() => {
-        user.tab();
-      });
+      await user.tab();
 
       expect(segments[0]).toHaveFocus();
       expect(onKeyDownSpy).not.toHaveBeenCalled();\n- packages/components/date-input/__tests__/time-input.test.tsx (modified, 31 changes)\n  Patch: @@ -1,6 +1,6 @@
 /* eslint-disable jsx-a11y/no-autofocus */
 import * as React from "react";
-import {act, fireEvent, render} from "@testing-library/react";
+import {fireEvent, render} from "@testing-library/react";
 import {Time, ZonedDateTime} from "@internationalized/date";
 import {TimeValue} from "@react-types/datepicker";
 import {pointerMap, triggerPress} from "@nextui-org/test-utils";
@@ -237,17 +237,13 @@ describe("TimeInput", () => {
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[0]).toHaveFocus();
 
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[1]).toHaveFocus();
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
@@ -268,22 +264,14 @@ describe("TimeInput", () => {
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[0]).toHaveFocus();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[1]).toHaveFocus();
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(segments[2]).toHaveFocus();
       expect(onBlurSpy).toHaveBeenCalledTimes(0);
-      await act(async () => {
-        await user.tab();
-      });
+      await user.tab();
       expect(onBlurSpy).toHaveBeenCalledTimes(1);
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(2);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
@@ -298,10 +286,7 @@ describe("TimeInput", () => {
       expect(onKeyDownSpy).not.toHaveBeenCalled();
       expect(onKeyUpSpy).not.toHaveBeenCalled();
 
-      await act(() => {
-        user.tab();
-      });
-
+      await user.tab();
       expect(segments[0]).toHaveFocus();
       expect(onKeyDownSpy).not.toHaveBeenCalled();
       expect(onKeyUpSpy).toHaveBeenCalledTimes(1);\n- packages/components/date-picker/__tests__/date-picker.test.tsx (modified, 30 changes)\n  Patch: @@ -246,19 +246,13 @@ describe("DatePicker", () => {
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       expect(segments[0]).toHaveFocus();
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       expect(segments[1]).toHaveFocus();
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
@@ -288,19 +282,13 @@ describe("DatePicker", () => {
       expect(onFocusChangeSpy).not.toHaveBeenCalled();
       expect(onFocusSpy).not.toHaveBeenCalled();
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       expect(segments[0]).toHaveFocus();
       expect(onBlurSpy).not.toHaveBeenCalled();
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(1);
       expect(onFocusSpy).toHaveBeenCalledTimes(1);
 
-      await act(() => {
-        user.click(document.body);
-      });
-
+      await user.click(document.body);
       expect(document.body).toHaveFocus();
       expect(onBlurSpy).toHaveBeenCalledTimes(1);
       expect(onFocusChangeSpy).toHaveBeenCalledTimes(2);
@@ -375,10 +363,7 @@ describe("DatePicker", () => {
       expect(document.activeElement).toBe(button);
       expect(button).toHaveFocus();
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       expect(document.body).toHaveFocus();
     });
 
@@ -391,10 +376,7 @@ describe("DatePicker", () => {
       expect(onKeyDownSpy).not.toHaveBeenCalled();
       expect(onKeyUpSpy).not.toHaveBeenCalled();
 
-      await act(async () => {
-        await user.tab();
-      });
-
+      await user.tab();
       expect(segments[0]).toHaveFocus();
       expect(onKeyDownSpy).not.toHaveBeenCalled();
       expect(onKeyUpSpy).toHaveBeenCalledTimes(1);\n- packages/components/dropdown/__tests__/dropdown.test.tsx (modified, 487 changes)\n  Patch: @@ -1,7 +1,7 @@
 import * as React from "react";
 import {act, render, fireEvent} from "@testing-library/react";
 import {Button} from "@nextui-org/button";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {keyCodes} from "@nextui-org/test-utils";
 import {User} from "@nextui-org/user";
 import {Image} from "@nextui-org/image";
@@ -14,6 +14,11 @@ import {Dropdown, DropdownTrigger, DropdownMenu, DropdownItem, DropdownSection}
 const spy = jest.spyOn(console, "error").mockImplementation(() => {});
 
 describe("Dropdown", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
   afterEach(() => {
     jest.clearAllMocks();
   });
@@ -144,11 +149,8 @@ describe("Dropdown", () => {
 
     expect(triggerButton).toBeTruthy();
 
-    await act(async () => {
-      await userEvent.click(triggerButton);
-    });
-
-    expect(spy).toBeCalledTimes(0);
+    await user.click(triggerButton);
+    expect(spy).toHaveBeenCalledTimes(0);
 
     let menu = wrapper.queryByRole("menu");
 
@@ -182,13 +184,11 @@ describe("Dropdown", () => {
 
     let triggerButton = wrapper.getByTestId("trigger-test");
 
-    expect(onOpenChange).toBeCalledTimes(0);
+    expect(onOpenChange).toHaveBeenCalledTimes(0);
 
-    act(() => {
-      triggerButton.click();
-    });
+    await user.click(triggerButton);
 
-    expect(onOpenChange).toBeCalledTimes(1);
+    expect(onOpenChange).toHaveBeenCalledTimes(1);
 
     let menu = wrapper.getByRole("menu");
 
@@ -201,12 +201,10 @@ describe("Dropdown", () => {
 
     expect(menuItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
+    await user.click(menuItems[1]);
 
-      expect(onSelectionChange).toBeCalledTimes(1);
-      expect(onOpenChange).toBeCalled();
-    });
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
+    expect(onOpenChange).toHaveBeenCalled();
   });
 
   it("should work with multiple selection (controlled)", async () => {
@@ -236,13 +234,11 @@ describe("Dropdown", () => {
 
     let triggerButton = wrapper.getByTestId("trigger-test");
 
-    expect(onOpenChange).toBeCalledTimes(0);
+    expect(onOpenChange).toHaveBeenCalledTimes(0);
 
-    act(() => {
-      triggerButton.click();
-    });
+    await user.click(triggerButton);
 
-    expect(onOpenChange).toBeCalledTimes(1);
+    expect(onOpenChange).toHaveBeenCalledTimes(1);
 
     let menu = wrapper.getByRole("menu");
 
@@ -255,12 +251,10 @@ describe("Dropdown", () => {
 
     expect(menuItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(menuItems[0]);
+    await user.click(menuItems[0]);
 
-      expect(onSelectionChange).toBeCalledTimes(1);
-      expect(onOpenChange).toBeCalled();
-    });
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
+    expect(onOpenChange).toHaveBeenCalled();
   });
 
   it("should show checkmarks if selectionMode is single and has a selected item", () => {
@@ -366,7 +360,7 @@ describe("Dropdown", () => {
     expect(checkmark1).toBeFalsy();
   });
 
-  it("should not open on disabled button", () => {
+  it("should not open on disabled button", async () => {
     const wrapper = render(
       <Dropdown>
         <DropdownTrigger>
@@ -389,16 +383,14 @@ describe("Dropdown", () => {
 
     expect(triggerButton).toBeTruthy();
 
-    act(() => {
-      triggerButton.click();
-    });
+    await user.click(triggerButton);
 
     let menu = wrapper.queryByRole("menu");
 
     expect(menu).toBeFalsy();
   });
 
-  it("should not open on disabled dropdown", () => {
+  it("should not open on disabled dropdown", async () => {
     const wrapper = render(
       <Dropdown isDisabled>
         <DropdownTrigger>
@@ -419,16 +411,14 @@ describe("Dropdown", () => {
 
     expect(triggerButton).toBeTruthy();
 
-    act(() => {
-      triggerButton.click();
-    });
+    await user.click(triggerButton);
 
     let menu = wrapper.queryByRole("menu");
 
     expect(menu).toBeFalsy();
   });
 
-  it("should not select on disabled item", () => {
+  it("should not select on disabled item", async () => {
     const onSelectionChange = jest.fn();
     const wrapper = render(
       <Dropdown isOpen>
@@ -455,11 +445,9 @@ describe("Dropdown", () => {
 
     expect(menuItems.length).toBe(4);
 
-    act(() => {
-      menuItems[1].click();
-    });
+    await user.click(menuItems[1]);
 
-    expect(onSelectionChange).toBeCalledTimes(0);
+    expect(onSelectionChange).toHaveBeenCalledTimes(0);
   });
 
   it("should render without error (custom trigger with isDisabled)", async () => {
@@ -488,7 +476,7 @@ describe("Dropdown", () => {
       </Dropdown>,
     );
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
 
     spy.mockRestore();
 
@@ -502,7 +490,7 @@ describe("Dropdown", () => {
       </Dropdown>,
     );
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
 
     spy.mockRestore();
 
@@ -516,7 +504,7 @@ describe("Dropdown", () => {
       </Dropdown>,
     );
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
 
     spy.mockRestore();
 
@@ -534,7 +522,7 @@ describe("Dropdown", () => {
       </Dropdown>,
     );
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
 
     spy.mockRestore();
   });
@@ -580,9 +568,7 @@ describe("Dropdown", () => {
     expect(dropdown2).not.toBeNull();
 
     // open the dropdown listbox by clicking dropdownor button in the first dropdown
-    await act(async () => {
-      await userEvent.click(dropdown);
-    });
+    await user.click(dropdown);
 
     // assert that the first dropdown listbox is open
     expect(dropdown).toHaveAttribute("aria-expanded", "true");
@@ -591,291 +577,270 @@ describe("Dropdown", () => {
     expect(dropdown2).toHaveAttribute("aria-expanded", "false");
 
     // close the dropdown listbox by clicking the second dropdown
-    await act(async () => {
-      await userEvent.click(dropdown2);
-    });
+    await user.click(dropdown2);
 
     // assert that the first dropdown listbox is closed
     expect(dropdown).toHaveAttribute("aria-expanded", "false");
 
     // assert that the second dropdown listbox is open
     expect(dropdown2).toHaveAttribute("aria-expanded", "true");
   });
-});
-
-describe("Keyboard interactions", () => {
-  it("should focus on the first item on keyDown (Enter)", async () => {
-    const wrapper = render(
-      <Dropdown>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu disallowEmptySelection aria-label="Actions" selectionMode="single">
-          <DropdownItem key="new">New file</DropdownItem>
-          <DropdownItem key="copy">Copy link</DropdownItem>
-          <DropdownItem key="edit">Edit file</DropdownItem>
-          <DropdownItem key="delete" color="danger">
-            Delete file
-          </DropdownItem>
-        </DropdownMenu>
-      </Dropdown>,
-    );
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+  describe("Keyboard interactions", () => {
+    it("should focus on the first item on keyDown (Enter)", async () => {
+      const wrapper = render(
+        <Dropdown>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu disallowEmptySelection aria-label="Actions" selectionMode="single">
+            <DropdownItem key="new">New file</DropdownItem>
+            <DropdownItem key="copy">Copy link</DropdownItem>
+            <DropdownItem key="edit">Edit file</DropdownItem>
+            <DropdownItem key="delete" color="danger">
+              Delete file
+            </DropdownItem>
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    act(() => {
-      triggerButton.focus();
-    });
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    expect(triggerButton).toHaveFocus();
+      act(() => {
+        triggerButton.focus();
+      });
 
-    fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
+      expect(triggerButton).toHaveFocus();
 
-    let menu = wrapper.queryByRole("menu");
+      fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
 
-    expect(menu).toBeTruthy();
+      let menu = wrapper.queryByRole("menu");
 
-    let menuItems = wrapper.getAllByRole("menuitemradio");
+      expect(menu).toBeTruthy();
 
-    expect(menuItems.length).toBe(4);
+      let menuItems = wrapper.getAllByRole("menuitemradio");
 
-    expect(menuItems[0]).toHaveFocus();
-  });
+      expect(menuItems.length).toBe(4);
 
-  it("should focus on the first item on keyDown (Space)", async () => {
-    const wrapper = render(
-      <Dropdown>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu disallowEmptySelection aria-label="Actions" selectionMode="single">
-          <DropdownItem key="new">New file</DropdownItem>
-          <DropdownItem key="copy">Copy link</DropdownItem>
-          <DropdownItem key="edit">Edit file</DropdownItem>
-          <DropdownItem key="delete" color="danger">
-            Delete file
-          </DropdownItem>
-        </DropdownMenu>
-      </Dropdown>,
-    );
+      expect(menuItems[0]).toHaveFocus();
+    });
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+    it("should focus on the first item on keyDown (Space)", async () => {
+      const wrapper = render(
+        <Dropdown>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu disallowEmptySelection aria-label="Actions" selectionMode="single">
+            <DropdownItem key="new">New file</DropdownItem>
+            <DropdownItem key="copy">Copy link</DropdownItem>
+            <DropdownItem key="edit">Edit file</DropdownItem>
+            <DropdownItem key="delete" color="danger">
+              Delete file
+            </DropdownItem>
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    act(() => {
-      triggerButton.focus();
-    });
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    expect(triggerButton).toHaveFocus();
+      act(() => {
+        triggerButton.focus();
+      });
 
-    fireEvent.keyDown(triggerButton, {key: " ", charCode: keyCodes[" "]});
+      expect(triggerButton).toHaveFocus();
 
-    let menu = wrapper.queryByRole("menu");
+      fireEvent.keyDown(triggerButton, {key: " ", charCode: keyCodes[" "]});
 
-    expect(menu).toBeTruthy();
+      let menu = wrapper.queryByRole("menu");
 
-    let menuItems = wrapper.getAllByRole("menuitemradio");
+      expect(menu).toBeTruthy();
 
-    expect(menuItems.length).toBe(4);
+      let menuItems = wrapper.getAllByRole("menuitemradio");
 
-    expect(menuItems[0]).toHaveFocus();
-  });
+      expect(menuItems.length).toBe(4);
 
-  it("should press the item on keyDown (Enter)", async () => {
-    const user = userEvent.setup();
+      expect(menuItems[0]).toHaveFocus();
+    });
 
-    const logSpy = jest.spyOn(console, "log").mockImplementation(() => {});
+    it("should press the item on keyDown (Enter)", async () => {
+      const logSpy = jest.spyOn(console, "log").mockImplementation(() => {});
 
-    const wrapper = render(
-      <Dropdown>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu aria-label="Actions" selectionMode="single">
-          <DropdownItem
-            key="new"
-            onPress={() => {
-              /* eslint-disable no-console */
-              console.log("ENTER");
-            }}
-          >
-            New file
-          </DropdownItem>
-          <DropdownItem key="copy">Copy link</DropdownItem>
-          <DropdownItem key="edit">Edit file</DropdownItem>
-          <DropdownItem key="delete" color="danger">
-            Delete file
-          </DropdownItem>
-        </DropdownMenu>
-      </Dropdown>,
-    );
+      const wrapper = render(
+        <Dropdown>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu aria-label="Actions" selectionMode="single">
+            <DropdownItem
+              key="new"
+              onPress={() => {
+                /* eslint-disable no-console */
+                console.log("ENTER");
+              }}
+            >
+              New file
+            </DropdownItem>
+            <DropdownItem key="copy">Copy link</DropdownItem>
+            <DropdownItem key="edit">Edit file</DropdownItem>
+            <DropdownItem key="delete" color="danger">
+              Delete file
+            </DropdownItem>
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    act(() => {
-      triggerButton.focus();
-    });
+      act(() => {
+        triggerButton.focus();
+      });
 
-    expect(triggerButton).toHaveFocus();
+      expect(triggerButton).toHaveFocus();
 
-    fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
+      fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
 
-    let menu = wrapper.queryByRole("menu");
+      let menu = wrapper.queryByRole("menu");
 
-    expect(menu).toBeTruthy();
+      expect(menu).toBeTruthy();
 
-    let menuItems = wrapper.getAllByRole("menuitemradio");
+      let menuItems = wrapper.getAllByRole("menuitemradio");
 
-    expect(menuItems.length).toBe(4);
+      expect(menuItems.length).toBe(4);
 
-    expect(menuItems[0]).toHaveFocus();
+      expect(menuItems[0]).toHaveFocus();
 
-    await act(async () => {
       await user.keyboard("[Enter]");
-    });
-
-    expect(logSpy).toHaveBeenCalledWith("ENTER");
 
-    logSpy.mockRestore();
-  });
+      expect(logSpy).toHaveBeenCalledWith("ENTER");
 
-  it("should press the item on keyDown (Space)", async () => {
-    const user = userEvent.setup();
+      logSpy.mockRestore();
+    });
 
-    const logSpy = jest.spyOn(console, "log").mockImplementation(() => {});
+    it("should press the item on keyDown (Space)", async () => {
+      const logSpy = jest.spyOn(console, "log").mockImplementation(() => {});
 
-    const wrapper = render(
-      <Dropdown>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu aria-label="Actions" selectionMode="single">
-          <DropdownItem
-            key="new"
-            onPress={() => {
-              /* eslint-disable no-console */
-              console.log("SPACE");
-            }}
-          >
-            New file
-          </DropdownItem>
-          <DropdownItem key="copy">Copy link</DropdownItem>
-          <DropdownItem key="edit">Edit file</DropdownItem>
-          <DropdownItem key="delete" color="danger">
-            Delete file
-          </DropdownItem>
-        </DropdownMenu>
-      </Dropdown>,
-    );
+      const wrapper = render(
+        <Dropdown>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu aria-label="Actions" selectionMode="single">
+            <DropdownItem
+              key="new"
+              onPress={() => {
+                /* eslint-disable no-console */
+                console.log("SPACE");
+              }}
+            >
+              New file
+            </DropdownItem>
+            <DropdownItem key="copy">Copy link</DropdownItem>
+            <DropdownItem key="edit">Edit file</DropdownItem>
+            <DropdownItem key="delete" color="danger">
+              Delete file
+            </DropdownItem>
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    act(() => {
-      triggerButton.focus();
-    });
+      act(() => {
+        triggerButton.focus();
+      });
 
-    expect(triggerButton).toHaveFocus();
+      expect(triggerButton).toHaveFocus();
 
-    fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
+      fireEvent.keyDown(triggerButton, {key: "Enter", charCode: keyCodes.Enter});
 
-    let menu = wrapper.queryByRole("menu");
+      let menu = wrapper.queryByRole("menu");
 
-    expect(menu).toBeTruthy();
+      expect(menu).toBeTruthy();
 
-    let menuItems = wrapper.getAllByRole("menuitemradio");
+      let menuItems = wrapper.getAllByRole("menuitemradio");
 
-    expect(menuItems.length).toBe(4);
+      expect(menuItems.length).toBe(4);
 
-    expect(menuItems[0]).toHaveFocus();
+      expect(menuItems[0]).toHaveFocus();
 
-    await act(async () => {
       await user.keyboard("[Space]");
-    });
 
-    expect(logSpy).toHaveBeenCalledWith("SPACE");
+      expect(logSpy).toHaveBeenCalledWith("SPACE");
 
-    logSpy.mockRestore();
-  });
+      logSpy.mockRestore();
+    });
 
-  it("should respect closeOnSelect setting of DropdownItem (static)", async () => {
-    const onOpenChange = jest.fn();
-    const wrapper = render(
-      <Dropdown onOpenChange={onOpenChange}>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu aria-label="Actions">
-          <DropdownItem key="new" closeOnSelect={false}>
-            New file
-          </DropdownItem>
-          <DropdownItem key="copy">Copy link</DropdownItem>
-        </DropdownMenu>
-      </Dropdown>,
-    );
+    it("should respect closeOnSelect setting of DropdownItem (static)", async () => {
+      const onOpenChange = jest.fn();
+      const wrapper = render(
+        <Dropdown onOpenChange={onOpenChange}>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu aria-label="Actions">
+            <DropdownItem key="new" closeOnSelect={false}>
+              New file
+            </DropdownItem>
+            <DropdownItem key="copy">Copy link</DropdownItem>
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    act(() => {
-      triggerButton.click();
-    });
-    expect(onOpenChange).toBeCalledTimes(1);
+      await user.click(triggerButton);
 
-    let menuItems = wrapper.getAllByRole("menuitem");
+      expect(onOpenChange).toHaveBeenCalledTimes(1);
 
-    await act(async () => {
-      await userEvent.click(menuItems[0]);
-      expect(onOpenChange).toBeCalledTimes(1);
-    });
+      let menuItems = wrapper.getAllByRole("menuitem");
+
+      await user.click(menuItems[0]);
+      expect(onOpenChange).toHaveBeenCalledTimes(1);
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
-      expect(onOpenChange).toBeCalledTimes(2);
+      await user.click(menuItems[1]);
+      expect(onOpenChange).toHaveBeenCalledTimes(2);
     });
-  });
 
-  it("should respect closeOnSelect setting of DropdownItem (dynamic)", async () => {
-    const onOpenChange = jest.fn();
-    const items = [
-      {
-        key: "new",
-        label: "New file",
-      },
-      {
-        key: "copy",
-        label: "Copy link",
-      },
-    ];
-    const wrapper = render(
-      <Dropdown onOpenChange={onOpenChange}>
-        <DropdownTrigger>
-          <Button data-testid="trigger-test">Trigger</Button>
-        </DropdownTrigger>
-        <DropdownMenu aria-label="Actions" items={items}>
-          {(item) => (
-            <DropdownItem key={item.key} closeOnSelect={item.key !== "new"}>
-              {item.label}
-            </DropdownItem>
-          )}
-        </DropdownMenu>
-      </Dropdown>,
-    );
+    it("should respect closeOnSelect setting of DropdownItem (dynamic)", async () => {
+      const onOpenChange = jest.fn();
+      const items = [
+        {
+          key: "new",
+          label: "New file",
+        },
+        {
+          key: "copy",
+          label: "Copy link",
+        },
+      ];
+      const wrapper = render(
+        <Dropdown onOpenChange={onOpenChange}>
+          <DropdownTrigger>
+            <Button data-testid="trigger-test">Trigger</Button>
+          </DropdownTrigger>
+          <DropdownMenu aria-label="Actions" items={items}>
+            {(item) => (
+              <DropdownItem key={item.key} closeOnSelect={item.key !== "new"}>
+                {item.label}
+              </DropdownItem>
+            )}
+          </DropdownMenu>
+        </Dropdown>,
+      );
 
-    let triggerButton = wrapper.getByTestId("trigger-test");
+      let triggerButton = wrapper.getByTestId("trigger-test");
 
-    act(() => {
-      triggerButton.click();
-    });
-    expect(onOpenChange).toBeCalledTimes(1);
+      await user.click(triggerButton);
+      expect(onOpenChange).toHaveBeenCalledTimes(1);
 
-    let menuItems = wrapper.getAllByRole("menuitem");
+      let menuItems = wrapper.getAllByRole("menuitem");
 
-    await act(async () => {
-      await userEvent.click(menuItems[0]);
-      expect(onOpenChange).toBeCalledTimes(1);
-    });
+      await user.click(menuItems[0]);
+      expect(onOpenChange).toHaveBeenCalledTimes(1);
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
-      expect(onOpenChange).toBeCalledTimes(2);
+      await user.click(menuItems[1]);
+      expect(onOpenChange).toHaveBeenCalledTimes(2);
     });
   });
 });\n- packages/components/listbox/__tests__/listbox.test.tsx (modified, 24 changes)\n  Patch: @@ -1,10 +1,16 @@
 import * as React from "react";
-import {act, render} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import {render} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {Listbox, ListboxItem, ListboxSection} from "../src";
 
 describe("Listbox", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(
       <Listbox aria-label="Actions" onAction={alert}>
@@ -145,11 +151,8 @@ describe("Listbox", () => {
 
     expect(listboxItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(listboxItems[1]);
-
-      expect(onSelectionChange).toBeCalledTimes(1);
-    });
+    await user.click(listboxItems[1]);
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
   });
 
   it("should work with multiple selection (controlled)", async () => {
@@ -179,11 +182,8 @@ describe("Listbox", () => {
 
     expect(listboxItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(listboxItems[0]);
-
-      expect(onSelectionChange).toBeCalledTimes(1);
-    });
+    await user.click(listboxItems[0]);
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
   });
 
   it("should show checkmarks if selectionMode is single and has a selected item", () => {\n- packages/components/menu/__tests__/menu.test.tsx (modified, 48 changes)\n  Patch: @@ -1,10 +1,16 @@
 import * as React from "react";
-import {act, render} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import {render} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {Menu, MenuItem, MenuSection} from "../src";
 
 describe("Menu", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(
       <Menu aria-label="Actions" onAction={alert}>
@@ -146,11 +152,8 @@ describe("Menu", () => {
 
     expect(menuItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
-
-      expect(onSelectionChange).toBeCalledTimes(1);
-    });
+    await user.click(menuItems[1]);
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
   });
 
   it("should work with multiple selection (controlled)", async () => {
@@ -180,11 +183,8 @@ describe("Menu", () => {
 
     expect(menuItems.length).toBe(4);
 
-    await act(async () => {
-      await userEvent.click(menuItems[0]);
-
-      expect(onSelectionChange).toBeCalledTimes(1);
-    });
+    await user.click(menuItems[0]);
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
   });
 
   it("should show checkmarks if selectionMode is single and has a selected item", () => {
@@ -291,11 +291,8 @@ describe("Menu", () => {
 
     let menuItems = wrapper.getAllByRole("menuitem");
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
-
-      expect(onAction).toBeCalledTimes(1);
-    });
+    await user.click(menuItems[1]);
+    expect(onAction).toHaveBeenCalledTimes(1);
   });
 
   it("should not dispatch onAction events if item is disabled", async () => {
@@ -316,11 +313,8 @@ describe("Menu", () => {
 
     let menuItems = wrapper.getAllByRole("menuitem");
 
-    await act(async () => {
-      await userEvent.click(menuItems[1]);
-
-      expect(onAction).toBeCalledTimes(0);
-    });
+    await user.click(menuItems[1]);
+    expect(onAction).toHaveBeenCalledTimes(0);
   });
 
   it("should dispatch onPress, onAction and onClick events", async () => {
@@ -343,12 +337,10 @@ describe("Menu", () => {
 
     let menuItems = wrapper.getAllByRole("menuitem");
 
-    await act(async () => {
-      await userEvent.click(menuItems[0]);
+    await user.click(menuItems[0]);
 
-      expect(onAction).toBeCalledTimes(1);
-      expect(onPress).toBeCalledTimes(1);
-      expect(onClick).toBeCalledTimes(1);
-    });
+    expect(onAction).toHaveBeenCalledTimes(1);
+    expect(onPress).toHaveBeenCalledTimes(1);
+    expect(onClick).toHaveBeenCalledTimes(1);
   });
 });\n- packages/components/modal/__tests__/modal.test.tsx (modified, 13 changes)\n  Patch: @@ -1,5 +1,6 @@
 import * as React from "react";
-import {act, render, fireEvent} from "@testing-library/react";
+import {render, fireEvent} from "@testing-library/react";
+import userEvent from "@testing-library/user-event";
 
 import {Modal, ModalContent, ModalBody, ModalHeader, ModalFooter} from "../src";
 
@@ -25,7 +26,7 @@ describe("Modal", () => {
 
     expect(() => wrapper.unmount()).not.toThrow();
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
   it("ref should be forwarded", () => {
@@ -68,7 +69,7 @@ describe("Modal", () => {
     expect(modal).toHaveAttribute("aria-describedby", modalBody.id);
   });
 
-  test("should fire 'onOpenChange' callback when close button is clicked", () => {
+  test("should fire 'onOpenChange' callback when close button is clicked", async () => {
     const onClose = jest.fn();
 
     const {getByLabelText} = render(
@@ -83,9 +84,9 @@ describe("Modal", () => {
 
     const closeButton = getByLabelText("Close");
 
-    act(() => {
-      closeButton.click();
-    });
+    const user = userEvent.setup();
+
+    await user.click(closeButton);
 
     expect(onClose).toHaveBeenCalled();
   });\n- packages/components/navbar/__tests__/navbar.test.tsx (modified, 30 changes)\n  Patch: @@ -1,5 +1,6 @@
 import * as React from "react";
-import {act, render} from "@testing-library/react";
+import {render} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {
   Navbar,
@@ -18,6 +19,12 @@ window.scrollTo = jest.fn();
 const spy = jest.spyOn(console, "error").mockImplementation(() => {});
 
 describe("Navbar", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   afterEach(() => {
     jest.clearAllMocks();
   });
@@ -62,7 +69,7 @@ describe("Navbar", () => {
     expect(navbarContent.children.length).toBe(5);
   });
 
-  it("should not throw error after toggle click", () => {
+  it("should not throw error after toggle click", async () => {
     const items = ["item1", "item2", "item3", "item4", "item5"];
 
     const wrapper = render(
@@ -85,14 +92,12 @@ describe("Navbar", () => {
 
     const toggle = wrapper.getByTestId("navbar-toggle-test");
 
-    act(() => {
-      toggle.click();
-    });
+    await user.click(toggle);
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
-  it("should render correctly with menu", () => {
+  it("should render correctly with menu", async () => {
     const items = ["item1", "item2", "item3", "item4", "item5"];
 
     const wrapper = render(
@@ -115,16 +120,13 @@ describe("Navbar", () => {
 
     const toggle = wrapper.getByTestId("navbar-toggle-test");
 
-    act(() => {
-      toggle.click();
-    });
-
+    await user.click(toggle);
     const menu = wrapper.getByTestId("navbar-menu-test");
 
     expect(menu.children.length).toBe(items.length);
   });
 
-  it("should call on onChange when toggle is clicked", () => {
+  it("should call on onChange when toggle is clicked", async () => {
     const onChange = jest.fn();
 
     const wrapper = render(
@@ -142,9 +144,7 @@ describe("Navbar", () => {
 
     const toggle = wrapper.getByTestId("navbar-toggle-test");
 
-    act(() => {
-      toggle.click();
-    });
+    await user.click(toggle);
 
     expect(onChange).toHaveBeenCalled();
   });\n- packages/components/popover/__tests__/popover.test.tsx (modified, 62 changes)\n  Patch: @@ -1,6 +1,6 @@
 import * as React from "react";
 import {render, fireEvent, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {Button} from "@nextui-org/button";
 
 import {Popover, PopoverContent, PopoverTrigger} from "../src";
@@ -11,6 +11,12 @@ import {Select, SelectItem} from "../../select/src";
 const spy = jest.spyOn(console, "error").mockImplementation(() => {});
 
 describe("Popover", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   afterEach(() => {
     jest.clearAllMocks();
   });
@@ -30,7 +36,7 @@ describe("Popover", () => {
     expect(() => wrapper.unmount()).not.toThrow();
   });
 
-  it("should not throw error when clicking trigger button", () => {
+  it("should not throw error when clicking trigger button", async () => {
     const wrapper = render(
       <Popover>
         <PopoverTrigger>
@@ -44,11 +50,9 @@ describe("Popover", () => {
     const trigger = wrapper.getByTestId("trigger-test");
 
     // open popover
-    act(() => {
-      trigger.click();
-    });
+    await user.click(trigger);
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
   it("ref should be forwarded", () => {
@@ -130,7 +134,7 @@ describe("Popover", () => {
     expect(onClose).toHaveBeenCalledTimes(1);
   });
 
-  it("should work with NextUI button", () => {
+  it("should work with NextUI button", async () => {
     const onClose = jest.fn();
 
     const wrapper = render(
@@ -149,15 +153,11 @@ describe("Popover", () => {
     const trigger = wrapper.getByTestId("trigger-test");
 
     // open popover
-    act(() => {
-      trigger.click();
-    });
+    await user.click(trigger);
     expect(onClose).toHaveBeenCalledTimes(0);
 
     // close popover
-    act(() => {
-      trigger.click();
-    });
+    await user.click(trigger);
 
     expect(onClose).toHaveBeenCalledTimes(1);
   });
@@ -193,9 +193,7 @@ describe("Popover", () => {
     expect(popover2).not.toBeNull();
 
     // open the popover by clicking popover in the first popover
-    await act(async () => {
-      await userEvent.click(popover);
-    });
+    await user.click(popover);
 
     // assert that the first popover is open
     expect(popover).toHaveAttribute("aria-expanded", "true");
@@ -204,9 +202,7 @@ describe("Popover", () => {
     expect(popover2).toHaveAttribute("aria-expanded", "false");
 
     // close the popover by clicking the second popover
-    await act(async () => {
-      await userEvent.click(popover2);
-    });
+    await user.click(popover2);
 
     // assert that the first popover is closed
     expect(popover).toHaveAttribute("aria-expanded", "false");
@@ -232,9 +228,7 @@ describe("Popover", () => {
     const trigger = wrapper.getByTestId("trigger-test");
 
     // open popover
-    await act(async () => {
-      await userEvent.click(trigger);
-    });
+    await user.click(trigger);
 
     const {getByRole} = wrapper;
 
@@ -260,9 +254,9 @@ describe("Popover", () => {
 
     await act(async () => {
       // open popover
-      await userEvent.click(trigger);
+      await user.click(trigger);
       // close popover
-      await userEvent.click(trigger);
+      await user.click(trigger);
       // assert that the focus is restored back to trigger
       expect(trigger).toHaveFocus();
     });
@@ -286,27 +280,21 @@ describe("Popover", () => {
 
     const popover = wrapper.getByTestId("popover");
 
-    await act(async () => {
-      // open popover
-      await userEvent.click(popover);
-    });
+    // open popover
+    await user.click(popover);
 
     // assert that the popover is open
     expect(popover).toHaveAttribute("aria-expanded", "true");
 
     const select = wrapper.getByTestId("select");
 
-    await act(async () => {
-      // open select
-      await userEvent.click(select);
-    });
+    // open select
+    await user.click(select);
 
     // assert that the select is open
     expect(select).toHaveAttribute("aria-expanded", "true");
 
-    await act(async () => {
-      await userEvent.click(document.body);
-    });
+    await user.click(document.body);
 
     // assert that the select is closed
     expect(select).toHaveAttribute("aria-expanded", "false");
@@ -334,9 +322,7 @@ describe("Popover", () => {
     const popover = wrapper.getByTestId("popover");
 
     // open popover
-    await act(async () => {
-      await userEvent.click(popover);
-    });
+    await user.click(popover);
 
     // assert that the popover is open
     expect(popover).toHaveAttribute("aria-expanded", "true");\n- packages/components/radio/__tests__/radio.test.tsx (modified, 42 changes)\n  Patch: @@ -1,10 +1,16 @@
 import * as React from "react";
 import {act, render} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {RadioGroup, Radio, RadioGroupProps} from "../src";
 
 describe("Radio", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(
       <RadioGroup label="Options">
@@ -62,7 +68,7 @@ describe("Radio", () => {
     expect(wrapper.container.querySelector("[data-testid=radio-test-2] input")).toBeChecked();
   });
 
-  it("should change value after click", () => {
+  it("should change value after click", async () => {
     const {container} = render(
       <RadioGroup defaultValue="1" label="Options">
         <Radio value="1">Option 1</Radio>
@@ -74,14 +80,11 @@ describe("Radio", () => {
 
     let radio2 = container.querySelector(".radio-test-2 input") as HTMLInputElement;
 
-    act(() => {
-      radio2.click();
-    });
-
+    await user.click(radio2);
     expect(radio2).toBeChecked();
   });
 
-  it("should ignore events when disabled", () => {
+  it("should ignore events when disabled", async () => {
     const {container} = render(
       <RadioGroup label="Options">
         <Radio isDisabled className="radio-test-1" value="1">
@@ -93,14 +96,11 @@ describe("Radio", () => {
 
     let radio1 = container.querySelector(".radio-test-1 input") as HTMLInputElement;
 
-    act(() => {
-      radio1.click();
-    });
-
+    await user.click(radio1);
     expect(radio1).not.toBeChecked();
   });
 
-  it('should work correctly with "onValueChange" prop', () => {
+  it('should work correctly with "onValueChange" prop', async () => {
     const onValueChange = jest.fn();
 
     const {container} = render(
@@ -114,11 +114,8 @@ describe("Radio", () => {
 
     let radio2 = container.querySelector(".radio-test-2 input") as HTMLInputElement;
 
-    act(() => {
-      radio2.click();
-    });
-
-    expect(onValueChange).toBeCalledWith("2");
+    await user.click(radio2);
+    expect(onValueChange).toHaveBeenCalledWith("2");
 
     expect(radio2).toBeChecked();
   });
@@ -141,7 +138,7 @@ describe("Radio", () => {
       radio2.focus();
     });
 
-    expect(onFocus).toBeCalled();
+    expect(onFocus).toHaveBeenCalled();
   });
 
   it("should have required attribute when isRequired with native validationBehavior", () => {
@@ -178,7 +175,7 @@ describe("Radio", () => {
     expect(radios[0]).not.toHaveAttribute("required");
   });
 
-  it("should work correctly with controlled value", () => {
+  it("should work correctly with controlled value", async () => {
     const onValueChange = jest.fn();
 
     const Component = ({onValueChange}: Omit<RadioGroupProps, "value">) => {
@@ -205,11 +202,8 @@ describe("Radio", () => {
 
     let radio2 = container.querySelector(".radio-test-2 input") as HTMLInputElement;
 
-    act(() => {
-      radio2.click();
-    });
-
-    expect(onValueChange).toBeCalled();
+    await user.click(radio2);
+    expect(onValueChange).toHaveBeenCalled();
 
     expect(radio2).toBeChecked();
   });\n- packages/components/select/__tests__/select.test.tsx (modified, 141 changes)\n  Patch: @@ -1,8 +1,8 @@
 import type {SelectProps} from "../src";
 
 import * as React from "react";
-import {render, renderHook, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import {render, renderHook} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {useForm} from "react-hook-form";
 
 import {Select, SelectItem, SelectSection} from "../src";
@@ -51,7 +51,7 @@ const itemsSectionData = [
 ];
 
 describe("Select", () => {
-  let user;
+  let user: UserEvent;
 
   beforeEach(() => {
     user = userEvent.setup();
@@ -153,11 +153,8 @@ describe("Select", () => {
 
     expect(listboxItems.length).toBe(3);
 
-    await act(async () => {
-      await user.click(listboxItems[1]);
-
-      expect(onSelectionChange).toBeCalledTimes(1);
-    });
+    await user.click(listboxItems[1]);
+    expect(onSelectionChange).toHaveBeenCalledTimes(1);
   });
 
   it("should work with multiple selection (controlled)", async () => {
@@ -186,12 +183,10 @@ describe("Select", () => {
 
     expect(listboxItems.length).toBe(3);
 
-    await act(async () => {
-      await user.click(listboxItems[1]);
-      await user.click(listboxItems[2]);
+    await user.click(listboxItems[1]);
+    await user.click(listboxItems[2]);
 
-      expect(onSelectionChange).toBeCalledTimes(2);
-    });
+    expect(onSelectionChange).toHaveBeenCalledTimes(2);
   });
 
   it("should work with dynamic placeholder and renderValue", async () => {
@@ -226,15 +221,11 @@ describe("Select", () => {
 
     const select = wrapper.getByTestId("render-selected-item-test");
 
-    await act(async () => {
-      await user.click(select);
-    });
+    await user.click(select);
 
     const listboxItems = wrapper.getAllByRole("option");
 
-    await act(async () => {
-      await user.click(listboxItems[0]);
-    });
+    await user.click(listboxItems[0]);
 
     expect(select).toHaveTextContent("Penguin");
     expect(wrapper.queryByText("Select an favorite animal")).toBe(null);
@@ -266,17 +257,13 @@ describe("Select", () => {
     const select = wrapper.getByTestId("close-when-clicking-outside-test");
 
     // open the select dropdown
-    await act(async () => {
-      await user.click(select);
-    });
+    await user.click(select);
 
     // assert that the select is open
     expect(select).toHaveAttribute("aria-expanded", "true");
 
     // click outside the select component
-    await act(async () => {
-      await user.click(document.body);
-    });
+    await user.click(document.body);
 
     // assert that the select is closed
     expect(select).toHaveAttribute("aria-expanded", "false");
@@ -306,17 +293,13 @@ describe("Select", () => {
     const select = wrapper.getByTestId("close-when-clicking-outside-test");
 
     // open the select dropdown
-    await act(async () => {
-      await user.click(select);
-    });
+    await user.click(select);
 
     // assert that the select is open
     expect(select).toHaveAttribute("aria-expanded", "true");
 
     // click outside the select component
-    await act(async () => {
-      await user.click(document.body);
-    });
+    await user.click(document.body);
 
     // assert that the select is closed
     expect(select).toHaveAttribute("aria-expanded", "false");
@@ -341,13 +324,11 @@ describe("Select", () => {
     );
     const select = wrapper.getByTestId("test-select");
 
-    await act(async () => {
-      await user.click(document.body);
-      await user.tab();
-      await user.type(select, "z", {skipClick: true});
+    await user.click(document.body);
+    await user.tab();
+    await user.type(select, "z", {skipClick: true});
 
-      expect(onSelectionChange).toBeCalledTimes(0);
-    });
+    expect(onSelectionChange).toHaveBeenCalledTimes(0);
   });
 
   it("should pre-select items based on defaultSelectedKeys (numeric keys)", () => {
@@ -424,17 +405,15 @@ describe("Select", () => {
     expect(listbox).toBeInTheDocument();
 
     // Select item and check the correct ID is passed to the callback
-    await act(async () => {
-      await user.click(wrapperWithId.getByRole("option", {name: itemsWithId[0].value}));
-    });
+    await user.click(wrapperWithId.getByRole("option", {name: itemsWithId[0].value}));
+
     expect(onSelectionChangeId).toHaveBeenCalled();
     let selectionArg = onSelectionChangeId.mock.calls[0][0];
 
     expect([...selectionArg]).toEqual([itemsWithId[0].id]);
 
-    await act(async () => {
-      await user.click(wrapperWithId.getByRole("option", {name: itemsWithId[1].value}));
-    });
+    await user.click(wrapperWithId.getByRole("option", {name: itemsWithId[1].value}));
+
     expect(onSelectionChangeId).toHaveBeenCalledTimes(2);
     selectionArg = onSelectionChangeId.mock.calls[1][0];
     expect([...selectionArg]).toEqual([itemsWithId[1].id]);
@@ -464,17 +443,15 @@ describe("Select", () => {
     expect(listbox).toBeInTheDocument();
 
     // Select item and check the correct key is passed to the callback
-    await act(async () => {
-      await user.click(wrapperWithKey.getByRole("option", {name: itemsWithKey[0].value}));
-    });
+    await user.click(wrapperWithKey.getByRole("option", {name: itemsWithKey[0].value}));
+
     expect(onSelectionChangeKey).toHaveBeenCalled();
     let selectionArg = onSelectionChangeKey.mock.calls[0][0];
 
     expect([...selectionArg]).toEqual([itemsWithKey[0].key]);
 
-    await act(async () => {
-      await user.click(wrapperWithKey.getByRole("option", {name: itemsWithKey[1].value}));
-    });
+    await user.click(wrapperWithKey.getByRole("option", {name: itemsWithKey[1].value}));
+
     expect(onSelectionChangeKey).toHaveBeenCalledTimes(2);
     selectionArg = onSelectionChangeKey.mock.calls[1][0];
     expect([...selectionArg]).toEqual([itemsWithKey[1].key]);
@@ -537,9 +514,7 @@ describe("Select", () => {
     expect(select2).not.toBeNull();
 
     // open the select listbox by clicking selector button in the first select
-    await act(async () => {
-      await userEvent.click(select);
-    });
+    await user.click(select);
 
     // assert that the first select listbox is open
     expect(select).toHaveAttribute("aria-expanded", "true");
@@ -548,9 +523,7 @@ describe("Select", () => {
     expect(select2).toHaveAttribute("aria-expanded", "false");
 
     // close the select listbox by clicking the second select
-    await act(async () => {
-      await userEvent.click(select2);
-    });
+    await user.click(select2);
 
     // assert that the first select listbox is closed
     expect(select).toHaveAttribute("aria-expanded", "false");
@@ -603,8 +576,6 @@ describe("Select", () => {
   it("should unset form value", async () => {
     const logSpy = jest.spyOn(console, "log");
 
-    const user = userEvent.setup();
-
     const wrapper = render(
       <form
         className="w-full max-w-xs items-end flex flex-col gap-4"
@@ -634,20 +605,14 @@ describe("Select", () => {
 
     const submitButton = wrapper.getByTestId("submit-button");
 
-    await act(async () => {
-      await user.click(submitButton);
-    });
-
+    await user.click(submitButton);
     expect(logSpy).toHaveBeenCalledWith(JSON.stringify({select: "foo"}));
 
     const select = wrapper.getByTestId("select");
 
     expect(select).not.toBeNull();
 
-    await act(async () => {
-      await user.click(select);
-    });
-
+    await user.click(select);
     const listbox = wrapper.getByRole("listbox");
 
     expect(listbox).toBeTruthy();
@@ -656,13 +621,8 @@ describe("Select", () => {
 
     expect(listboxItems.length).toBe(2);
 
-    await act(async () => {
-      await user.click(listboxItems[0]);
-    });
-
-    await act(async () => {
-      await user.click(submitButton);
-    });
+    await user.click(listboxItems[0]);
+    await user.click(submitButton);
 
     expect(logSpy).toHaveBeenCalledWith(JSON.stringify({select: ""}));
   });
@@ -682,22 +642,18 @@ describe("Select", () => {
       </Select>,
     );
 
-    const select = wrapper.getByTestId("select");
+    const select = await wrapper.findByTestId("select");
 
     expect(select).not.toBeNull();
 
     // open the select listbox by clicking selector button
-    await act(async () => {
-      await userEvent.click(select);
-    });
+    await user.click(select);
 
     // assert that the select listbox is open
     expect(select).toHaveAttribute("aria-expanded", "true");
 
     // open the select listbox by clicking selector button
-    await act(async () => {
-      await userEvent.click(select);
-    });
+    await user.click(select);
 
     // assert that the select listbox is closed
     expect(select).toHaveAttribute("aria-expanded", "false");
@@ -730,11 +686,9 @@ describe("Select", () => {
 
     expect(listboxItems.length).toBe(10);
 
-    await act(async () => {
-      await user.click(listboxItems[1]);
+    await user.click(listboxItems[1]);
 
-      expect(onChange).toBeCalledTimes(1);
-    });
+    expect(onChange).toHaveBeenCalledTimes(1);
   });
 
   it("should work with onChange (>= 300 select items)", async () => {
@@ -764,11 +718,9 @@ describe("Select", () => {
 
     expect(listboxItems.length).toBe(300);
 
-    await act(async () => {
-      await user.click(listboxItems[1]);
+    await user.click(listboxItems[1]);
 
-      expect(onChange).toBeCalledTimes(1);
-    });
+    expect(onChange).toHaveBeenCalledTimes(1);
   });
 
   it("should place the label outside when labelPlacement is outside", () => {
@@ -858,18 +810,29 @@ describe("Select with React Hook Form", () => {
 
     wrapper = render(
       <form className="flex flex-col gap-4" onSubmit={handleSubmit(onSubmit)}>
-        <Select data-testid="select-1" items={itemsData} {...register("withDefaultValue")}>
+        <Select
+          data-testid="select-1"
+          items={itemsData}
+          {...register("withDefaultValue")}
+          aria-label="select-1"
+        >
           {(item) => <SelectItem key={item.id}>{item.label}</SelectItem>}
         </Select>
 
-        <Select data-testid="select-2" items={itemsData} {...register("withoutDefaultValue")}>
+        <Select
+          data-testid="select-2"
+          items={itemsData}
+          {...register("withoutDefaultValue")}
+          aria-label="select-2"
+        >
           {(item) => <SelectItem key={item.id}>{item.label}</SelectItem>}
         </Select>
 
         <Select
           data-testid="select-3"
           items={itemsData}
           {...register("requiredField", {required: true})}
+          aria-label="select-3"
         >
           {(item) => <SelectItem key={item.id}>{item.label}</SelectItem>}
         </Select>\n- packages/components/slider/__tests__/slider.test.tsx (modified, 26 changes)\n  Patch: @@ -1,10 +1,16 @@
 import * as React from "react";
 import {render, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {Slider, SliderValue} from "../src";
 
 describe("Slider", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(<Slider />);
 
@@ -138,9 +144,7 @@ describe("Slider", () => {
     expect(output).toHaveTextContent("50");
 
     // change slider value
-    await act(async () => {
-      await userEvent.click(button);
-    });
+    await user.click(button);
 
     expect(slider).toHaveProperty("value", "55");
     expect(slider).toHaveAttribute("aria-valuetext", "55");
@@ -201,9 +205,7 @@ describe("Slider", () => {
     expect(rightSlider).toHaveAttribute("aria-valuetext", "20");
 
     // change slider value
-    await act(async () => {
-      await userEvent.click(button);
-    });
+    await user.click(button);
 
     expect(leftSlider).toHaveProperty("value", "15");
     expect(leftSlider).toHaveAttribute("aria-valuetext", "15");
@@ -318,10 +320,7 @@ describe("Slider", () => {
 
     expect(marks).toHaveLength(3);
 
-    await act(async () => {
-      await userEvent.click(marks[1]);
-    });
-
+    await user.click(marks[1]);
     const slider = getByRole("slider");
 
     expect(slider).toHaveProperty("value", "0.5");
@@ -358,10 +357,7 @@ describe("Slider", () => {
 
     expect(marks).toHaveLength(3);
 
-    await act(async () => {
-      await userEvent.click(marks[1]);
-    });
-
+    await user.click(marks[1]);
     const [leftSlider, rightSlider] = getAllByRole("slider");
 
     expect(leftSlider).toHaveProperty("value", "0.5");\n- packages/components/switch/__tests__/switch.test.tsx (modified, 64 changes)\n  Patch: @@ -1,11 +1,17 @@
 import * as React from "react";
-import {render, renderHook, act} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import {render, renderHook} from "@testing-library/react";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {useForm} from "react-hook-form";
 
 import {Switch} from "../src";
 
 describe("Switch", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(<Switch aria-label="switch" />);
 
@@ -19,35 +25,26 @@ describe("Switch", () => {
     expect(ref.current).not.toBeNull();
   });
 
-  it("should check and uncheck", () => {
+  it("should check and uncheck", async () => {
     const {getByRole} = render(<Switch aria-label="switch" />);
 
     const checkbox = getByRole("switch");
 
     expect(checkbox).not.toBeChecked();
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).toBeChecked();
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).not.toBeChecked();
   });
 
-  it("should not check if disabled", () => {
+  it("should not check if disabled", async () => {
     const {getByRole} = render(<Switch isDisabled aria-label="switch" />);
 
     const checkbox = getByRole("switch");
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).not.toBeChecked();
   });
 
@@ -59,19 +56,16 @@ describe("Switch", () => {
     expect(checkbox).toBeChecked();
   });
 
-  it("should not check if readOnly", () => {
+  it("should not check if readOnly", async () => {
     const {getByRole} = render(<Switch isReadOnly aria-label="switch" />);
 
     const checkbox = getByRole("switch");
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).not.toBeChecked();
   });
 
-  it("should check and uncheck with controlled state", () => {
+  it("should check and uncheck with controlled state", async () => {
     const ControlledSwitch = ({onChange}: any) => {
       const [isSelected, setIsSelected] = React.useState(false);
 
@@ -95,10 +89,7 @@ describe("Switch", () => {
 
     expect(checkbox).not.toBeChecked();
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).toBeChecked();
 
     expect(onChange).toHaveBeenCalledWith(true);
@@ -121,7 +112,7 @@ describe("Switch", () => {
     expect(wrapper.getByTestId("thumb-icon")).toBeInTheDocument();
   });
 
-  it("should change the thumbIcon when clicked", () => {
+  it("should change the thumbIcon when clicked", async () => {
     const thumbIcon = jest.fn((props) => {
       const {isSelected} = props;
 
@@ -138,10 +129,7 @@ describe("Switch", () => {
 
     expect(checkbox).not.toBeChecked();
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).toBeChecked();
 
     expect(thumbIcon).toHaveBeenCalledWith(
@@ -154,10 +142,7 @@ describe("Switch", () => {
 
     expect(checkedthumbIcon).toBeInTheDocument();
 
-    act(() => {
-      checkbox.click();
-    });
-
+    await user.click(checkbox);
     expect(checkbox).not.toBeChecked();
 
     expect(thumbIcon).toHaveBeenCalledWith(
@@ -253,21 +238,16 @@ describe("Switch with React Hook Form", () => {
     const user = userEvent.setup();
 
     await user.click(submitButton);
-
     expect(onSubmit).toHaveBeenCalledTimes(0);
   });
 
   it("should submit form when required field is not empty", async () => {
-    act(() => {
-      switch3.click();
-    });
+    const user = userEvent.setup();
 
+    await switch3.click();
     expect(switch3.checked).toBe(true);
 
-    const user = userEvent.setup();
-
     await user.click(submitButton);
-
     expect(onSubmit).toHaveBeenCalledTimes(1);
   });
 });\n- packages/components/table/__tests__/table.test.tsx (modified, 25 changes)\n  Patch: @@ -1,6 +1,6 @@
 import * as React from "react";
 import {act, render} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 
 import {Table, TableHeader, TableCell, TableColumn, TableBody, TableRow} from "../src";
 
@@ -16,6 +16,12 @@ let items = [
 ];
 
 describe("Table", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
+
   it("should render correctly", () => {
     const wrapper = render(
       <Table aria-label="Test example table">
@@ -131,7 +137,7 @@ describe("Table", () => {
     expect(wrapper.getAllByRole("gridcell")).toHaveLength(4);
   });
 
-  it("should work with single selectionMode='single'", () => {
+  it("should work with single selectionMode='single'", async () => {
     const onRowAction = jest.fn();
 
     const wrapper = render(
@@ -163,14 +169,11 @@ describe("Table", () => {
     // get the first row
     const row1 = wrapper.getAllByRole("row")[1];
 
-    act(() => {
-      row1.click();
-    });
-
+    await user.click(row1);
     expect(onRowAction).toHaveBeenCalledTimes(1);
   });
 
-  it("should work with single selectionMode='multiple'", () => {
+  it("should work with single selectionMode='multiple'", async () => {
     const onRowAction = jest.fn();
 
     const wrapper = render(
@@ -207,15 +210,13 @@ describe("Table", () => {
     const row1 = wrapper.getAllByRole("row")[1];
     const row2 = wrapper.getAllByRole("row")[2];
 
-    act(() => {
-      row1.click();
-      row2.click();
-    });
+    await user.click(row1);
+    await user.click(row2);
 
     expect(onRowAction).toHaveBeenCalledTimes(2);
   });
 
-  it("should set the proper aria-sort on an ascending sorted column header", () => {
+  it("should set the proper aria-sort on an ascending sorted column header", async () => {
     const wrapper = render(
       <Table aria-label="Static Table">
         <TableHeader>\n- packages/components/tabs/__tests__/tabs.test.tsx (modified, 54 changes)\n  Patch: @@ -1,6 +1,6 @@
 import * as React from "react";
 import {act, render, fireEvent, within} from "@testing-library/react";
-import userEvent from "@testing-library/user-event";
+import userEvent, {UserEvent} from "@testing-library/user-event";
 import {focus} from "@nextui-org/test-utils";
 
 import {Tabs, Tab, TabsProps} from "../src";
@@ -50,6 +50,11 @@ function getPlacementTemplate(position: TabsProps["placement"]) {
 const spy = jest.spyOn(console, "error").mockImplementation(() => {});
 
 describe("Tabs", () => {
+  let user: UserEvent;
+
+  beforeEach(() => {
+    user = userEvent.setup();
+  });
   afterEach(() => {
     jest.clearAllMocks();
   });
@@ -71,7 +76,7 @@ describe("Tabs", () => {
 
     expect(() => wrapper.unmount()).not.toThrow();
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
   it("should render correctly (dynamic)", () => {
@@ -168,26 +173,17 @@ describe("Tabs", () => {
       focus(tab1);
     });
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab1).toHaveAttribute("aria-selected", "false");
     expect(tab2).toHaveAttribute("aria-selected", "true");
     expect(tab3).toHaveAttribute("aria-selected", "false");
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab1).toHaveAttribute("aria-selected", "false");
     expect(tab2).toHaveAttribute("aria-selected", "false");
     expect(tab3).toHaveAttribute("aria-selected", "true");
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab1).toHaveAttribute("aria-selected", "true");
     expect(tab2).toHaveAttribute("aria-selected", "false");
     expect(tab3).toHaveAttribute("aria-selected", "false");
@@ -220,22 +216,13 @@ describe("Tabs", () => {
       focus(tab1);
     });
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab2).toHaveFocus();
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab3).toHaveFocus();
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowLeft]");
-    });
-
+    await user.keyboard("[ArrowLeft]");
     expect(tab2).toHaveFocus();
 
     expect(tab1).toHaveAttribute("aria-selected", "true");
@@ -280,10 +267,7 @@ describe("Tabs", () => {
 
     const tab2 = wrapper.getByTestId("item2");
 
-    await act(async () => {
-      await userEvent.click(tab2);
-    });
-
+    await user.click(tab2);
     expect(tab2).toHaveAttribute("aria-selected", "false");
   });
 
@@ -396,16 +380,10 @@ describe("Tabs", () => {
       focus(tab1);
     });
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowRight]");
-    });
-
+    await user.keyboard("[ArrowRight]");
     expect(tab2).toHaveFocus();
 
-    await act(async () => {
-      await userEvent.keyboard("[ArrowLeft]");
-    });
-
+    await user.keyboard("[ArrowLeft]");
     expect(tab1).toHaveFocus();
 
     expect(input).toHaveValue("23");\n- packages/components/tooltip/__tests__/tooltip.test.tsx (modified, 2 changes)\n  Patch: @@ -30,7 +30,7 @@ describe("Tooltip", () => {
 
     expect(() => wrapper.unmount()).not.toThrow();
 
-    expect(spy).toBeCalledTimes(0);
+    expect(spy).toHaveBeenCalledTimes(0);
   });
 
   it("ref should be forwarded", () => {\n- packages/hooks/use-clipboard/__tests__/clipboard.test.tsx (modified, 2 changes)\n  Patch: @@ -1,4 +1,4 @@
-import {renderHook, act} from "@testing-library/react-hooks";
+import {renderHook, act} from "@testing-library/react";
 
 import {useClipboard} from "../src";
 \n- packages/hooks/use-pagination/__tests__/use-pagination.test.tsx (modified, 4 changes)\n  Patch: @@ -1,4 +1,4 @@
-import {renderHook, act} from "@testing-library/react-hooks";
+import {renderHook, act} from "@testing-library/react";
 
 import {usePagination} from "../src";
 
@@ -97,6 +97,6 @@ describe("usePagination", () => {
     const {result} = renderHook(() => usePagination({total: 10, onChange}));
 
     act(() => result.current.setPage(5));
-    expect(onChange).toBeCalledWith(5);
+    expect(onChange).toHaveBeenCalledWith(5);
   });
 });\n- packages/hooks/use-ref-state/__tests__/use-ref-state.test.tsx (modified, 2 changes)\n  Patch: @@ -1,5 +1,5 @@
 import * as React from "react";
-import {renderHook, act} from "@testing-library/react-hooks";
+import {renderHook, act} from "@testing-library/react";
 import {render} from "@testing-library/react";
 
 import {useRefState} from "../src";\n